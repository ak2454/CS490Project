{"ast":null,"code":"'use strict';\n\nvar FieldFlags = require('../constants/field_flags.js');\n\nvar Charsets = require('../constants/charsets.js');\n\nvar Types = require('../constants/types.js');\n\nvar helpers = require('../helpers');\n\nvar genFunc = require('generate-function');\n\nvar parserCache = require('./parser_cache.js');\n\nvar typeNames = [];\n\nfor (var t in Types) {\n  typeNames[Types[t]] = t;\n}\n\nfunction readCodeFor(field, config, options, fieldNum) {\n  var supportBigNumbers = options.supportBigNumbers || config.supportBigNumbers;\n  var bigNumberStrings = options.bigNumberStrings || config.bigNumberStrings;\n  var timezone = options.timezone || config.timezone;\n  var dateStrings = options.dateStrings || config.dateStrings;\n  var unsigned = field.flags & FieldFlags.UNSIGNED;\n\n  switch (field.columnType) {\n    case Types.TINY:\n      return unsigned ? 'packet.readInt8();' : 'packet.readSInt8();';\n\n    case Types.SHORT:\n      return unsigned ? 'packet.readInt16();' : 'packet.readSInt16();';\n\n    case Types.LONG:\n    case Types.INT24:\n      // in binary protocol int24 is encoded in 4 bytes int32\n      return unsigned ? 'packet.readInt32();' : 'packet.readSInt32();';\n\n    case Types.YEAR:\n      return 'packet.readInt16()';\n\n    case Types.FLOAT:\n      return 'packet.readFloat();';\n\n    case Types.DOUBLE:\n      return 'packet.readDouble();';\n\n    case Types.NULL:\n      return 'null;';\n\n    case Types.DATE:\n    case Types.DATETIME:\n    case Types.TIMESTAMP:\n    case Types.NEWDATE:\n      if (helpers.typeMatch(field.columnType, dateStrings, Types)) {\n        return \"packet.readDateTimeString(\".concat(field.decimals, \");\");\n      }\n\n      return \"packet.readDateTime('\".concat(timezone, \"');\");\n\n    case Types.TIME:\n      return 'packet.readTimeString()';\n\n    case Types.DECIMAL:\n    case Types.NEWDECIMAL:\n      if (config.decimalNumbers) {\n        return 'packet.parseLengthCodedFloat();';\n      }\n\n      return 'packet.readLengthCodedString(\"ascii\");';\n\n    case Types.GEOMETRY:\n      return 'packet.parseGeometryValue();';\n\n    case Types.JSON:\n      // Since for JSON columns mysql always returns charset 63 (BINARY),\n      // we have to handle it according to JSON specs and use \"utf8\",\n      // see https://github.com/sidorares/node-mysql2/issues/409\n      return 'JSON.parse(packet.readLengthCodedString(\"utf8\"));';\n\n    case Types.LONGLONG:\n      if (!supportBigNumbers) {\n        return unsigned ? 'packet.readInt64JSNumber();' : 'packet.readSInt64JSNumber();';\n      }\n\n      if (bigNumberStrings) {\n        return unsigned ? 'packet.readInt64String();' : 'packet.readSInt64String();';\n      }\n\n      return unsigned ? 'packet.readInt64();' : 'packet.readSInt64();';\n\n    default:\n      if (field.characterSet === Charsets.BINARY) {\n        return 'packet.readLengthCodedBuffer();';\n      }\n\n      return \"packet.readLengthCodedString(CharsetToEncoding[fields[\".concat(fieldNum, \"].characterSet])\");\n  }\n}\n\nfunction compile(fields, options, config) {\n  var parserFn = genFunc();\n  var i = 0;\n  var nullBitmapLength = Math.floor((fields.length + 7 + 2) / 8);\n  /* eslint-disable no-trailing-spaces */\n\n  /* eslint-disable no-spaced-func */\n\n  /* eslint-disable no-unexpected-multiline */\n\n  parserFn('(function(){')('return function BinaryRow(packet, fields, options, CharsetToEncoding) {');\n\n  if (options.rowsAsArray) {\n    parserFn(\"const result = new Array(\".concat(fields.length, \");\"));\n  }\n\n  var resultTables = {};\n  var resultTablesArray = [];\n\n  if (options.nestTables === true) {\n    for (i = 0; i < fields.length; i++) {\n      resultTables[fields[i].table] = 1;\n    }\n\n    resultTablesArray = Object.keys(resultTables);\n\n    for (i = 0; i < resultTablesArray.length; i++) {\n      parserFn(\"this[\".concat(helpers.srcEscape(resultTablesArray[i]), \"] = {};\"));\n    }\n  }\n\n  parserFn('packet.readInt8();'); // status byte\n\n  for (i = 0; i < nullBitmapLength; ++i) {\n    parserFn(\"const nullBitmaskByte\".concat(i, \" = packet.readInt8();\"));\n  }\n\n  var lvalue = '';\n  var currentFieldNullBit = 4;\n  var nullByteIndex = 0;\n  var fieldName = '';\n  var tableName = '';\n\n  for (i = 0; i < fields.length; i++) {\n    fieldName = helpers.srcEscape(fields[i].name);\n    parserFn(\"// \".concat(fieldName, \": \").concat(typeNames[fields[i].columnType]));\n\n    if (typeof options.nestTables === 'string') {\n      tableName = helpers.srcEscape(fields[i].table);\n      lvalue = \"this[\".concat(helpers.srcEscape(fields[i].table + options.nestTables + fields[i].name), \"]\");\n    } else if (options.nestTables === true) {\n      tableName = helpers.srcEscape(fields[i].table);\n      lvalue = \"this[\".concat(tableName, \"][\").concat(fieldName, \"]\");\n    } else if (options.rowsAsArray) {\n      lvalue = \"result[\".concat(i.toString(10), \"]\");\n    } else {\n      lvalue = \"this[\".concat(helpers.srcEscape(fields[i].name), \"]\");\n    } // TODO: this used to be an optimisation ( if column marked as NOT_NULL don't include code to check null\n    // bitmap at all, but it seems that we can't rely on this flag, see #178\n    // TODO: benchmark performance difference\n    //\n    // if (fields[i].flags & FieldFlags.NOT_NULL) { // don't need to check null bitmap if field can't be null.\n    //  result.push(lvalue + ' = ' + readCodeFor(fields[i], config));\n    // } else if (fields[i].columnType == Types.NULL) {\n    //  result.push(lvalue + ' = null;');\n    // } else {\n\n\n    parserFn(\"if (nullBitmaskByte\".concat(nullByteIndex, \" & \").concat(currentFieldNullBit, \")\"));\n    parserFn(\"\".concat(lvalue, \" = null;\"));\n    parserFn('else');\n    parserFn(\"\".concat(lvalue, \" = \").concat(readCodeFor(fields[i], config, options, i))); // }\n\n    currentFieldNullBit *= 2;\n\n    if (currentFieldNullBit === 0x100) {\n      currentFieldNullBit = 1;\n      nullByteIndex++;\n    }\n  }\n\n  if (options.rowsAsArray) {\n    parserFn('return result;');\n  }\n\n  parserFn('};')('})()');\n  /* eslint-enable no-trailing-spaces */\n\n  /* eslint-enable no-spaced-func */\n\n  /* eslint-enable no-unexpected-multiline */\n\n  if (config.debug) {\n    helpers.printDebugWithCode('Compiled binary protocol row parser', parserFn.toString());\n  }\n\n  return parserFn.toFunction();\n}\n\nfunction getBinaryParser(fields, options, config) {\n  return parserCache.getParser('binary', fields, options, config, compile);\n}\n\nmodule.exports = getBinaryParser;","map":{"version":3,"sources":["/root/Test/node_modules/mysql2/lib/parsers/binary_parser.js"],"names":["FieldFlags","require","Charsets","Types","helpers","genFunc","parserCache","typeNames","t","readCodeFor","field","config","options","fieldNum","supportBigNumbers","bigNumberStrings","timezone","dateStrings","unsigned","flags","UNSIGNED","columnType","TINY","SHORT","LONG","INT24","YEAR","FLOAT","DOUBLE","NULL","DATE","DATETIME","TIMESTAMP","NEWDATE","typeMatch","decimals","TIME","DECIMAL","NEWDECIMAL","decimalNumbers","GEOMETRY","JSON","LONGLONG","characterSet","BINARY","compile","fields","parserFn","i","nullBitmapLength","Math","floor","length","rowsAsArray","resultTables","resultTablesArray","nestTables","table","Object","keys","srcEscape","lvalue","currentFieldNullBit","nullByteIndex","fieldName","tableName","name","toString","debug","printDebugWithCode","toFunction","getBinaryParser","getParser","module","exports"],"mappings":"AAAA;;AAEA,IAAMA,UAAU,GAAGC,OAAO,CAAC,6BAAD,CAA1B;;AACA,IAAMC,QAAQ,GAAGD,OAAO,CAAC,0BAAD,CAAxB;;AACA,IAAME,KAAK,GAAGF,OAAO,CAAC,uBAAD,CAArB;;AACA,IAAMG,OAAO,GAAGH,OAAO,CAAC,YAAD,CAAvB;;AACA,IAAMI,OAAO,GAAGJ,OAAO,CAAC,mBAAD,CAAvB;;AACA,IAAMK,WAAW,GAAGL,OAAO,CAAC,mBAAD,CAA3B;;AACA,IAAMM,SAAS,GAAG,EAAlB;;AACA,KAAK,IAAMC,CAAX,IAAgBL,KAAhB,EAAuB;AACrBI,EAAAA,SAAS,CAACJ,KAAK,CAACK,CAAD,CAAN,CAAT,GAAsBA,CAAtB;AACD;;AAED,SAASC,WAAT,CAAqBC,KAArB,EAA4BC,MAA5B,EAAoCC,OAApC,EAA6CC,QAA7C,EAAuD;AACrD,MAAMC,iBAAiB,GACrBF,OAAO,CAACE,iBAAR,IAA6BH,MAAM,CAACG,iBADtC;AAEA,MAAMC,gBAAgB,GAAGH,OAAO,CAACG,gBAAR,IAA4BJ,MAAM,CAACI,gBAA5D;AACA,MAAMC,QAAQ,GAAGJ,OAAO,CAACI,QAAR,IAAoBL,MAAM,CAACK,QAA5C;AACA,MAAMC,WAAW,GAAGL,OAAO,CAACK,WAAR,IAAuBN,MAAM,CAACM,WAAlD;AACA,MAAMC,QAAQ,GAAGR,KAAK,CAACS,KAAN,GAAcnB,UAAU,CAACoB,QAA1C;;AACA,UAAQV,KAAK,CAACW,UAAd;AACE,SAAKlB,KAAK,CAACmB,IAAX;AACE,aAAOJ,QAAQ,GAAG,oBAAH,GAA0B,qBAAzC;;AACF,SAAKf,KAAK,CAACoB,KAAX;AACE,aAAOL,QAAQ,GAAG,qBAAH,GAA2B,sBAA1C;;AACF,SAAKf,KAAK,CAACqB,IAAX;AACA,SAAKrB,KAAK,CAACsB,KAAX;AAAkB;AAChB,aAAOP,QAAQ,GAAG,qBAAH,GAA2B,sBAA1C;;AACF,SAAKf,KAAK,CAACuB,IAAX;AACE,aAAO,oBAAP;;AACF,SAAKvB,KAAK,CAACwB,KAAX;AACE,aAAO,qBAAP;;AACF,SAAKxB,KAAK,CAACyB,MAAX;AACE,aAAO,sBAAP;;AACF,SAAKzB,KAAK,CAAC0B,IAAX;AACE,aAAO,OAAP;;AACF,SAAK1B,KAAK,CAAC2B,IAAX;AACA,SAAK3B,KAAK,CAAC4B,QAAX;AACA,SAAK5B,KAAK,CAAC6B,SAAX;AACA,SAAK7B,KAAK,CAAC8B,OAAX;AACE,UAAI7B,OAAO,CAAC8B,SAAR,CAAkBxB,KAAK,CAACW,UAAxB,EAAoCJ,WAApC,EAAiDd,KAAjD,CAAJ,EAA6D;AAC3D,mDAAoCO,KAAK,CAACyB,QAA1C;AACD;;AACD,4CAA+BnB,QAA/B;;AACF,SAAKb,KAAK,CAACiC,IAAX;AACE,aAAO,yBAAP;;AACF,SAAKjC,KAAK,CAACkC,OAAX;AACA,SAAKlC,KAAK,CAACmC,UAAX;AACE,UAAI3B,MAAM,CAAC4B,cAAX,EAA2B;AACzB,eAAO,iCAAP;AACD;;AACD,aAAO,wCAAP;;AACF,SAAKpC,KAAK,CAACqC,QAAX;AACE,aAAO,8BAAP;;AACF,SAAKrC,KAAK,CAACsC,IAAX;AACE;AACA;AACA;AACA,aAAO,mDAAP;;AACF,SAAKtC,KAAK,CAACuC,QAAX;AACE,UAAI,CAAC5B,iBAAL,EAAwB;AACtB,eAAOI,QAAQ,GACX,6BADW,GAEX,8BAFJ;AAGD;;AACD,UAAIH,gBAAJ,EAAsB;AACpB,eAAOG,QAAQ,GACX,2BADW,GAEX,4BAFJ;AAGD;;AACD,aAAOA,QAAQ,GAAG,qBAAH,GAA2B,sBAA1C;;AAEF;AACE,UAAIR,KAAK,CAACiC,YAAN,KAAuBzC,QAAQ,CAAC0C,MAApC,EAA4C;AAC1C,eAAO,iCAAP;AACD;;AACD,6EAAgE/B,QAAhE;AAxDJ;AA0DD;;AAED,SAASgC,OAAT,CAAiBC,MAAjB,EAAyBlC,OAAzB,EAAkCD,MAAlC,EAA0C;AACxC,MAAMoC,QAAQ,GAAG1C,OAAO,EAAxB;AACA,MAAI2C,CAAC,GAAG,CAAR;AACA,MAAMC,gBAAgB,GAAGC,IAAI,CAACC,KAAL,CAAW,CAACL,MAAM,CAACM,MAAP,GAAgB,CAAhB,GAAoB,CAArB,IAA0B,CAArC,CAAzB;AAEA;;AACA;;AACA;;AAEAL,EAAAA,QAAQ,CAAC,cAAD,CAAR,CACE,yEADF;;AAIA,MAAInC,OAAO,CAACyC,WAAZ,EAAyB;AACvBN,IAAAA,QAAQ,oCAA6BD,MAAM,CAACM,MAApC,QAAR;AACD;;AAED,MAAME,YAAY,GAAG,EAArB;AACA,MAAIC,iBAAiB,GAAG,EAAxB;;AAEA,MAAI3C,OAAO,CAAC4C,UAAR,KAAuB,IAA3B,EAAiC;AAC/B,SAAKR,CAAC,GAAG,CAAT,EAAYA,CAAC,GAAGF,MAAM,CAACM,MAAvB,EAA+BJ,CAAC,EAAhC,EAAoC;AAClCM,MAAAA,YAAY,CAACR,MAAM,CAACE,CAAD,CAAN,CAAUS,KAAX,CAAZ,GAAgC,CAAhC;AACD;;AACDF,IAAAA,iBAAiB,GAAGG,MAAM,CAACC,IAAP,CAAYL,YAAZ,CAApB;;AACA,SAAKN,CAAC,GAAG,CAAT,EAAYA,CAAC,GAAGO,iBAAiB,CAACH,MAAlC,EAA0CJ,CAAC,EAA3C,EAA+C;AAC7CD,MAAAA,QAAQ,gBAAS3C,OAAO,CAACwD,SAAR,CAAkBL,iBAAiB,CAACP,CAAD,CAAnC,CAAT,aAAR;AACD;AACF;;AAEDD,EAAAA,QAAQ,CAAC,oBAAD,CAAR,CA9BwC,CA8BR;;AAChC,OAAKC,CAAC,GAAG,CAAT,EAAYA,CAAC,GAAGC,gBAAhB,EAAkC,EAAED,CAApC,EAAuC;AACrCD,IAAAA,QAAQ,gCAAyBC,CAAzB,2BAAR;AACD;;AAED,MAAIa,MAAM,GAAG,EAAb;AACA,MAAIC,mBAAmB,GAAG,CAA1B;AACA,MAAIC,aAAa,GAAG,CAApB;AACA,MAAIC,SAAS,GAAG,EAAhB;AACA,MAAIC,SAAS,GAAG,EAAhB;;AAEA,OAAKjB,CAAC,GAAG,CAAT,EAAYA,CAAC,GAAGF,MAAM,CAACM,MAAvB,EAA+BJ,CAAC,EAAhC,EAAoC;AAClCgB,IAAAA,SAAS,GAAG5D,OAAO,CAACwD,SAAR,CAAkBd,MAAM,CAACE,CAAD,CAAN,CAAUkB,IAA5B,CAAZ;AACAnB,IAAAA,QAAQ,cAAOiB,SAAP,eAAqBzD,SAAS,CAACuC,MAAM,CAACE,CAAD,CAAN,CAAU3B,UAAX,CAA9B,EAAR;;AAEA,QAAI,OAAOT,OAAO,CAAC4C,UAAf,KAA8B,QAAlC,EAA4C;AAC1CS,MAAAA,SAAS,GAAG7D,OAAO,CAACwD,SAAR,CAAkBd,MAAM,CAACE,CAAD,CAAN,CAAUS,KAA5B,CAAZ;AACAI,MAAAA,MAAM,kBAAWzD,OAAO,CAACwD,SAAR,CACfd,MAAM,CAACE,CAAD,CAAN,CAAUS,KAAV,GAAkB7C,OAAO,CAAC4C,UAA1B,GAAuCV,MAAM,CAACE,CAAD,CAAN,CAAUkB,IADlC,CAAX,MAAN;AAGD,KALD,MAKO,IAAItD,OAAO,CAAC4C,UAAR,KAAuB,IAA3B,EAAiC;AACtCS,MAAAA,SAAS,GAAG7D,OAAO,CAACwD,SAAR,CAAkBd,MAAM,CAACE,CAAD,CAAN,CAAUS,KAA5B,CAAZ;AACAI,MAAAA,MAAM,kBAAWI,SAAX,eAAyBD,SAAzB,MAAN;AACD,KAHM,MAGA,IAAIpD,OAAO,CAACyC,WAAZ,EAAyB;AAC9BQ,MAAAA,MAAM,oBAAab,CAAC,CAACmB,QAAF,CAAW,EAAX,CAAb,MAAN;AACD,KAFM,MAEA;AACLN,MAAAA,MAAM,kBAAWzD,OAAO,CAACwD,SAAR,CAAkBd,MAAM,CAACE,CAAD,CAAN,CAAUkB,IAA5B,CAAX,MAAN;AACD,KAhBiC,CAkBlC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACAnB,IAAAA,QAAQ,8BAAuBgB,aAAvB,gBAA0CD,mBAA1C,OAAR;AACAf,IAAAA,QAAQ,WAAIc,MAAJ,cAAR;AACAd,IAAAA,QAAQ,CAAC,MAAD,CAAR;AACAA,IAAAA,QAAQ,WAAIc,MAAJ,gBAAgBpD,WAAW,CAACqC,MAAM,CAACE,CAAD,CAAP,EAAYrC,MAAZ,EAAoBC,OAApB,EAA6BoC,CAA7B,CAA3B,EAAR,CA9BkC,CA+BlC;;AACAc,IAAAA,mBAAmB,IAAI,CAAvB;;AACA,QAAIA,mBAAmB,KAAK,KAA5B,EAAmC;AACjCA,MAAAA,mBAAmB,GAAG,CAAtB;AACAC,MAAAA,aAAa;AACd;AACF;;AAED,MAAInD,OAAO,CAACyC,WAAZ,EAAyB;AACvBN,IAAAA,QAAQ,CAAC,gBAAD,CAAR;AACD;;AAEDA,EAAAA,QAAQ,CAAC,IAAD,CAAR,CAAe,MAAf;AAEA;;AACA;;AACA;;AAEA,MAAIpC,MAAM,CAACyD,KAAX,EAAkB;AAChBhE,IAAAA,OAAO,CAACiE,kBAAR,CACE,qCADF,EAEEtB,QAAQ,CAACoB,QAAT,EAFF;AAID;;AACD,SAAOpB,QAAQ,CAACuB,UAAT,EAAP;AACD;;AAED,SAASC,eAAT,CAAyBzB,MAAzB,EAAiClC,OAAjC,EAA0CD,MAA1C,EAAkD;AAChD,SAAOL,WAAW,CAACkE,SAAZ,CAAsB,QAAtB,EAAgC1B,MAAhC,EAAwClC,OAAxC,EAAiDD,MAAjD,EAAyDkC,OAAzD,CAAP;AACD;;AAED4B,MAAM,CAACC,OAAP,GAAiBH,eAAjB","sourcesContent":["'use strict';\n\nconst FieldFlags = require('../constants/field_flags.js');\nconst Charsets = require('../constants/charsets.js');\nconst Types = require('../constants/types.js');\nconst helpers = require('../helpers');\nconst genFunc = require('generate-function');\nconst parserCache = require('./parser_cache.js');\nconst typeNames = [];\nfor (const t in Types) {\n  typeNames[Types[t]] = t;\n}\n\nfunction readCodeFor(field, config, options, fieldNum) {\n  const supportBigNumbers =\n    options.supportBigNumbers || config.supportBigNumbers;\n  const bigNumberStrings = options.bigNumberStrings || config.bigNumberStrings;\n  const timezone = options.timezone || config.timezone;\n  const dateStrings = options.dateStrings || config.dateStrings;\n  const unsigned = field.flags & FieldFlags.UNSIGNED;\n  switch (field.columnType) {\n    case Types.TINY:\n      return unsigned ? 'packet.readInt8();' : 'packet.readSInt8();';\n    case Types.SHORT:\n      return unsigned ? 'packet.readInt16();' : 'packet.readSInt16();';\n    case Types.LONG:\n    case Types.INT24: // in binary protocol int24 is encoded in 4 bytes int32\n      return unsigned ? 'packet.readInt32();' : 'packet.readSInt32();';\n    case Types.YEAR:\n      return 'packet.readInt16()';\n    case Types.FLOAT:\n      return 'packet.readFloat();';\n    case Types.DOUBLE:\n      return 'packet.readDouble();';\n    case Types.NULL:\n      return 'null;';\n    case Types.DATE:\n    case Types.DATETIME:\n    case Types.TIMESTAMP:\n    case Types.NEWDATE:\n      if (helpers.typeMatch(field.columnType, dateStrings, Types)) {\n        return `packet.readDateTimeString(${field.decimals});`;\n      }\n      return `packet.readDateTime('${timezone}');`;\n    case Types.TIME:\n      return 'packet.readTimeString()';\n    case Types.DECIMAL:\n    case Types.NEWDECIMAL:\n      if (config.decimalNumbers) {\n        return 'packet.parseLengthCodedFloat();';\n      }\n      return 'packet.readLengthCodedString(\"ascii\");';\n    case Types.GEOMETRY:\n      return 'packet.parseGeometryValue();';\n    case Types.JSON:\n      // Since for JSON columns mysql always returns charset 63 (BINARY),\n      // we have to handle it according to JSON specs and use \"utf8\",\n      // see https://github.com/sidorares/node-mysql2/issues/409\n      return 'JSON.parse(packet.readLengthCodedString(\"utf8\"));';\n    case Types.LONGLONG:\n      if (!supportBigNumbers) {\n        return unsigned\n          ? 'packet.readInt64JSNumber();'\n          : 'packet.readSInt64JSNumber();';\n      }\n      if (bigNumberStrings) {\n        return unsigned\n          ? 'packet.readInt64String();'\n          : 'packet.readSInt64String();';\n      }\n      return unsigned ? 'packet.readInt64();' : 'packet.readSInt64();';\n\n    default:\n      if (field.characterSet === Charsets.BINARY) {\n        return 'packet.readLengthCodedBuffer();';\n      }\n      return `packet.readLengthCodedString(CharsetToEncoding[fields[${fieldNum}].characterSet])`;\n  }\n}\n\nfunction compile(fields, options, config) {\n  const parserFn = genFunc();\n  let i = 0;\n  const nullBitmapLength = Math.floor((fields.length + 7 + 2) / 8);\n\n  /* eslint-disable no-trailing-spaces */\n  /* eslint-disable no-spaced-func */\n  /* eslint-disable no-unexpected-multiline */\n\n  parserFn('(function(){')(\n    'return function BinaryRow(packet, fields, options, CharsetToEncoding) {'\n  );\n\n  if (options.rowsAsArray) {\n    parserFn(`const result = new Array(${fields.length});`);\n  }\n\n  const resultTables = {};\n  let resultTablesArray = [];\n\n  if (options.nestTables === true) {\n    for (i = 0; i < fields.length; i++) {\n      resultTables[fields[i].table] = 1;\n    }\n    resultTablesArray = Object.keys(resultTables);\n    for (i = 0; i < resultTablesArray.length; i++) {\n      parserFn(`this[${helpers.srcEscape(resultTablesArray[i])}] = {};`);\n    }\n  }\n\n  parserFn('packet.readInt8();'); // status byte\n  for (i = 0; i < nullBitmapLength; ++i) {\n    parserFn(`const nullBitmaskByte${i} = packet.readInt8();`);\n  }\n\n  let lvalue = '';\n  let currentFieldNullBit = 4;\n  let nullByteIndex = 0;\n  let fieldName = '';\n  let tableName = '';\n\n  for (i = 0; i < fields.length; i++) {\n    fieldName = helpers.srcEscape(fields[i].name);\n    parserFn(`// ${fieldName}: ${typeNames[fields[i].columnType]}`);\n\n    if (typeof options.nestTables === 'string') {\n      tableName = helpers.srcEscape(fields[i].table);\n      lvalue = `this[${helpers.srcEscape(\n        fields[i].table + options.nestTables + fields[i].name\n      )}]`;\n    } else if (options.nestTables === true) {\n      tableName = helpers.srcEscape(fields[i].table);\n      lvalue = `this[${tableName}][${fieldName}]`;\n    } else if (options.rowsAsArray) {\n      lvalue = `result[${i.toString(10)}]`;\n    } else {\n      lvalue = `this[${helpers.srcEscape(fields[i].name)}]`;\n    }\n\n    // TODO: this used to be an optimisation ( if column marked as NOT_NULL don't include code to check null\n    // bitmap at all, but it seems that we can't rely on this flag, see #178\n    // TODO: benchmark performance difference\n    //\n    // if (fields[i].flags & FieldFlags.NOT_NULL) { // don't need to check null bitmap if field can't be null.\n    //  result.push(lvalue + ' = ' + readCodeFor(fields[i], config));\n    // } else if (fields[i].columnType == Types.NULL) {\n    //  result.push(lvalue + ' = null;');\n    // } else {\n    parserFn(`if (nullBitmaskByte${nullByteIndex} & ${currentFieldNullBit})`);\n    parserFn(`${lvalue} = null;`);\n    parserFn('else');\n    parserFn(`${lvalue} = ${readCodeFor(fields[i], config, options, i)}`);\n    // }\n    currentFieldNullBit *= 2;\n    if (currentFieldNullBit === 0x100) {\n      currentFieldNullBit = 1;\n      nullByteIndex++;\n    }\n  }\n\n  if (options.rowsAsArray) {\n    parserFn('return result;');\n  }\n\n  parserFn('};')('})()');\n\n  /* eslint-enable no-trailing-spaces */\n  /* eslint-enable no-spaced-func */\n  /* eslint-enable no-unexpected-multiline */\n\n  if (config.debug) {\n    helpers.printDebugWithCode(\n      'Compiled binary protocol row parser',\n      parserFn.toString()\n    );\n  }\n  return parserFn.toFunction();\n}\n\nfunction getBinaryParser(fields, options, config) {\n  return parserCache.getParser('binary', fields, options, config, compile);\n}\n\nmodule.exports = getBinaryParser;\n"]},"metadata":{},"sourceType":"script"}