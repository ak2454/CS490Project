{"ast":null,"code":"'use strict';\n\nvar _classCallCheck = require(\"/root/Test/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/root/Test/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar CursorType = require('../constants/cursor');\n\nvar CommandCodes = require('../constants/commands');\n\nvar Types = require('../constants/types');\n\nvar Packet = require('../packets/packet');\n\nvar CharsetToEncoding = require('../constants/charset_encodings.js');\n\nfunction isJSON(value) {\n  return Array.isArray(value) || value.constructor === Object || typeof value.toJSON === 'function' && !Buffer.isBuffer(value);\n}\n/**\n * Converts a value to an object describing type, String/Buffer representation and length\n * @param {*} value\n */\n\n\nfunction toParameter(value, encoding, timezone) {\n  var type = Types.VAR_STRING;\n  var length;\n\n  var writer = function writer(value) {\n    // eslint-disable-next-line no-invalid-this\n    return Packet.prototype.writeLengthCodedString.call(this, value, encoding);\n  };\n\n  if (value !== null) {\n    switch (typeof value) {\n      case 'undefined':\n        throw new TypeError('Bind parameters must not contain undefined');\n\n      case 'number':\n        type = Types.DOUBLE;\n        length = 8;\n        writer = Packet.prototype.writeDouble;\n        break;\n\n      case 'boolean':\n        value = value | 0;\n        type = Types.TINY;\n        length = 1;\n        writer = Packet.prototype.writeInt8;\n        break;\n\n      case 'object':\n        if (Object.prototype.toString.call(value) === '[object Date]') {\n          type = Types.DATETIME;\n          length = 12;\n\n          writer = function writer(value) {\n            // eslint-disable-next-line no-invalid-this\n            return Packet.prototype.writeDate.call(this, value, timezone);\n          };\n        } else if (isJSON(value)) {\n          value = JSON.stringify(value);\n          type = Types.JSON;\n        } else if (Buffer.isBuffer(value)) {\n          length = Packet.lengthCodedNumberLength(value.length) + value.length;\n          writer = Packet.prototype.writeLengthCodedBuffer;\n        }\n\n        break;\n\n      default:\n        value = value.toString();\n    }\n  } else {\n    value = '';\n    type = Types.NULL;\n  }\n\n  if (!length) {\n    length = Packet.lengthCodedStringLength(value, encoding);\n  }\n\n  return {\n    value: value,\n    type: type,\n    length: length,\n    writer: writer\n  };\n}\n\nvar Execute = /*#__PURE__*/function () {\n  function Execute(id, parameters, charsetNumber, timezone) {\n    _classCallCheck(this, Execute);\n\n    this.id = id;\n    this.parameters = parameters;\n    this.encoding = CharsetToEncoding[charsetNumber];\n    this.timezone = timezone;\n  }\n\n  _createClass(Execute, [{\n    key: \"toPacket\",\n    value: function toPacket() {\n      var _this = this;\n\n      // TODO: don't try to calculate packet length in advance, allocate some big buffer in advance (header + 256 bytes?)\n      // and copy + reallocate if not enough\n      // 0 + 4 - length, seqId\n      // 4 + 1 - COM_EXECUTE\n      // 5 + 4 - stmtId\n      // 9 + 1 - flags\n      // 10 + 4 - iteration-count (always 1)\n      var length = 14;\n      var parameters;\n\n      if (this.parameters && this.parameters.length > 0) {\n        length += Math.floor((this.parameters.length + 7) / 8);\n        length += 1; // new-params-bound-flag\n\n        length += 2 * this.parameters.length; // type byte for each parameter if new-params-bound-flag is set\n\n        parameters = this.parameters.map(function (value) {\n          return toParameter(value, _this.encoding, _this.timezone);\n        });\n        length += parameters.reduce(function (accumulator, parameter) {\n          return accumulator + parameter.length;\n        }, 0);\n      }\n\n      var buffer = Buffer.allocUnsafe(length);\n      var packet = new Packet(0, buffer, 0, length);\n      packet.offset = 4;\n      packet.writeInt8(CommandCodes.STMT_EXECUTE);\n      packet.writeInt32(this.id);\n      packet.writeInt8(CursorType.NO_CURSOR); // flags\n\n      packet.writeInt32(1); // iteration-count, always 1\n\n      if (parameters) {\n        var bitmap = 0;\n        var bitValue = 1;\n        parameters.forEach(function (parameter) {\n          if (parameter.type === Types.NULL) {\n            bitmap += bitValue;\n          }\n\n          bitValue *= 2;\n\n          if (bitValue === 256) {\n            packet.writeInt8(bitmap);\n            bitmap = 0;\n            bitValue = 1;\n          }\n        });\n\n        if (bitValue !== 1) {\n          packet.writeInt8(bitmap);\n        } // TODO: explain meaning of the flag\n        // afaik, if set n*2 bytes with type of parameter are sent before parameters\n        // if not, previous execution types are used (TODO prooflink)\n\n\n        packet.writeInt8(1); // new-params-bound-flag\n        // Write parameter types\n\n        parameters.forEach(function (parameter) {\n          packet.writeInt8(parameter.type); // field type\n\n          packet.writeInt8(0); // parameter flag\n        }); // Write parameter values\n\n        parameters.forEach(function (parameter) {\n          if (parameter.type !== Types.NULL) {\n            parameter.writer.call(packet, parameter.value);\n          }\n        });\n      }\n\n      return packet;\n    }\n  }]);\n\n  return Execute;\n}();\n\nmodule.exports = Execute;","map":{"version":3,"sources":["/root/Test/node_modules/mysql2/lib/packets/execute.js"],"names":["CursorType","require","CommandCodes","Types","Packet","CharsetToEncoding","isJSON","value","Array","isArray","constructor","Object","toJSON","Buffer","isBuffer","toParameter","encoding","timezone","type","VAR_STRING","length","writer","prototype","writeLengthCodedString","call","TypeError","DOUBLE","writeDouble","TINY","writeInt8","toString","DATETIME","writeDate","JSON","stringify","lengthCodedNumberLength","writeLengthCodedBuffer","NULL","lengthCodedStringLength","Execute","id","parameters","charsetNumber","Math","floor","map","reduce","accumulator","parameter","buffer","allocUnsafe","packet","offset","STMT_EXECUTE","writeInt32","NO_CURSOR","bitmap","bitValue","forEach","module","exports"],"mappings":"AAAA;;;;;;AAEA,IAAMA,UAAU,GAAGC,OAAO,CAAC,qBAAD,CAA1B;;AACA,IAAMC,YAAY,GAAGD,OAAO,CAAC,uBAAD,CAA5B;;AACA,IAAME,KAAK,GAAGF,OAAO,CAAC,oBAAD,CAArB;;AACA,IAAMG,MAAM,GAAGH,OAAO,CAAC,mBAAD,CAAtB;;AACA,IAAMI,iBAAiB,GAAGJ,OAAO,CAAC,mCAAD,CAAjC;;AAEA,SAASK,MAAT,CAAgBC,KAAhB,EAAuB;AACrB,SACEC,KAAK,CAACC,OAAN,CAAcF,KAAd,KACAA,KAAK,CAACG,WAAN,KAAsBC,MADtB,IAEC,OAAOJ,KAAK,CAACK,MAAb,KAAwB,UAAxB,IAAsC,CAACC,MAAM,CAACC,QAAP,CAAgBP,KAAhB,CAH1C;AAKD;AAED;AACA;AACA;AACA;;;AACA,SAASQ,WAAT,CAAqBR,KAArB,EAA4BS,QAA5B,EAAsCC,QAAtC,EAAgD;AAC9C,MAAIC,IAAI,GAAGf,KAAK,CAACgB,UAAjB;AACA,MAAIC,MAAJ;;AACA,MAAIC,MAAM,GAAG,gBAASd,KAAT,EAAgB;AAC3B;AACA,WAAOH,MAAM,CAACkB,SAAP,CAAiBC,sBAAjB,CAAwCC,IAAxC,CAA6C,IAA7C,EAAmDjB,KAAnD,EAA0DS,QAA1D,CAAP;AACD,GAHD;;AAIA,MAAIT,KAAK,KAAK,IAAd,EAAoB;AAClB,YAAQ,OAAOA,KAAf;AACE,WAAK,WAAL;AACE,cAAM,IAAIkB,SAAJ,CAAc,4CAAd,CAAN;;AAEF,WAAK,QAAL;AACEP,QAAAA,IAAI,GAAGf,KAAK,CAACuB,MAAb;AACAN,QAAAA,MAAM,GAAG,CAAT;AACAC,QAAAA,MAAM,GAAGjB,MAAM,CAACkB,SAAP,CAAiBK,WAA1B;AACA;;AAEF,WAAK,SAAL;AACEpB,QAAAA,KAAK,GAAGA,KAAK,GAAG,CAAhB;AACAW,QAAAA,IAAI,GAAGf,KAAK,CAACyB,IAAb;AACAR,QAAAA,MAAM,GAAG,CAAT;AACAC,QAAAA,MAAM,GAAGjB,MAAM,CAACkB,SAAP,CAAiBO,SAA1B;AACA;;AAEF,WAAK,QAAL;AACE,YAAIlB,MAAM,CAACW,SAAP,CAAiBQ,QAAjB,CAA0BN,IAA1B,CAA+BjB,KAA/B,MAA0C,eAA9C,EAA+D;AAC7DW,UAAAA,IAAI,GAAGf,KAAK,CAAC4B,QAAb;AACAX,UAAAA,MAAM,GAAG,EAAT;;AACAC,UAAAA,MAAM,GAAG,gBAASd,KAAT,EAAgB;AACvB;AACA,mBAAOH,MAAM,CAACkB,SAAP,CAAiBU,SAAjB,CAA2BR,IAA3B,CAAgC,IAAhC,EAAsCjB,KAAtC,EAA6CU,QAA7C,CAAP;AACD,WAHD;AAID,SAPD,MAOO,IAAIX,MAAM,CAACC,KAAD,CAAV,EAAmB;AACxBA,UAAAA,KAAK,GAAG0B,IAAI,CAACC,SAAL,CAAe3B,KAAf,CAAR;AACAW,UAAAA,IAAI,GAAGf,KAAK,CAAC8B,IAAb;AACD,SAHM,MAGA,IAAIpB,MAAM,CAACC,QAAP,CAAgBP,KAAhB,CAAJ,EAA4B;AACjCa,UAAAA,MAAM,GAAGhB,MAAM,CAAC+B,uBAAP,CAA+B5B,KAAK,CAACa,MAArC,IAA+Cb,KAAK,CAACa,MAA9D;AACAC,UAAAA,MAAM,GAAGjB,MAAM,CAACkB,SAAP,CAAiBc,sBAA1B;AACD;;AACD;;AAEF;AACE7B,QAAAA,KAAK,GAAGA,KAAK,CAACuB,QAAN,EAAR;AAnCJ;AAqCD,GAtCD,MAsCO;AACLvB,IAAAA,KAAK,GAAG,EAAR;AACAW,IAAAA,IAAI,GAAGf,KAAK,CAACkC,IAAb;AACD;;AACD,MAAI,CAACjB,MAAL,EAAa;AACXA,IAAAA,MAAM,GAAGhB,MAAM,CAACkC,uBAAP,CAA+B/B,KAA/B,EAAsCS,QAAtC,CAAT;AACD;;AACD,SAAO;AAAET,IAAAA,KAAK,EAALA,KAAF;AAASW,IAAAA,IAAI,EAAJA,IAAT;AAAeE,IAAAA,MAAM,EAANA,MAAf;AAAuBC,IAAAA,MAAM,EAANA;AAAvB,GAAP;AACD;;IAEKkB,O;AACJ,mBAAYC,EAAZ,EAAgBC,UAAhB,EAA4BC,aAA5B,EAA2CzB,QAA3C,EAAqD;AAAA;;AACnD,SAAKuB,EAAL,GAAUA,EAAV;AACA,SAAKC,UAAL,GAAkBA,UAAlB;AACA,SAAKzB,QAAL,GAAgBX,iBAAiB,CAACqC,aAAD,CAAjC;AACA,SAAKzB,QAAL,GAAgBA,QAAhB;AACD;;;;WAED,oBAAW;AAAA;;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAIG,MAAM,GAAG,EAAb;AACA,UAAIqB,UAAJ;;AACA,UAAI,KAAKA,UAAL,IAAmB,KAAKA,UAAL,CAAgBrB,MAAhB,GAAyB,CAAhD,EAAmD;AACjDA,QAAAA,MAAM,IAAIuB,IAAI,CAACC,KAAL,CAAW,CAAC,KAAKH,UAAL,CAAgBrB,MAAhB,GAAyB,CAA1B,IAA+B,CAA1C,CAAV;AACAA,QAAAA,MAAM,IAAI,CAAV,CAFiD,CAEpC;;AACbA,QAAAA,MAAM,IAAI,IAAI,KAAKqB,UAAL,CAAgBrB,MAA9B,CAHiD,CAGX;;AACtCqB,QAAAA,UAAU,GAAG,KAAKA,UAAL,CAAgBI,GAAhB,CAAoB,UAAAtC,KAAK;AAAA,iBACpCQ,WAAW,CAACR,KAAD,EAAQ,KAAI,CAACS,QAAb,EAAuB,KAAI,CAACC,QAA5B,CADyB;AAAA,SAAzB,CAAb;AAGAG,QAAAA,MAAM,IAAIqB,UAAU,CAACK,MAAX,CACR,UAACC,WAAD,EAAcC,SAAd;AAAA,iBAA4BD,WAAW,GAAGC,SAAS,CAAC5B,MAApD;AAAA,SADQ,EAER,CAFQ,CAAV;AAID;;AACD,UAAM6B,MAAM,GAAGpC,MAAM,CAACqC,WAAP,CAAmB9B,MAAnB,CAAf;AACA,UAAM+B,MAAM,GAAG,IAAI/C,MAAJ,CAAW,CAAX,EAAc6C,MAAd,EAAsB,CAAtB,EAAyB7B,MAAzB,CAAf;AACA+B,MAAAA,MAAM,CAACC,MAAP,GAAgB,CAAhB;AACAD,MAAAA,MAAM,CAACtB,SAAP,CAAiB3B,YAAY,CAACmD,YAA9B;AACAF,MAAAA,MAAM,CAACG,UAAP,CAAkB,KAAKd,EAAvB;AACAW,MAAAA,MAAM,CAACtB,SAAP,CAAiB7B,UAAU,CAACuD,SAA5B,EA3BS,CA2B+B;;AACxCJ,MAAAA,MAAM,CAACG,UAAP,CAAkB,CAAlB,EA5BS,CA4Ba;;AACtB,UAAIb,UAAJ,EAAgB;AACd,YAAIe,MAAM,GAAG,CAAb;AACA,YAAIC,QAAQ,GAAG,CAAf;AACAhB,QAAAA,UAAU,CAACiB,OAAX,CAAmB,UAAAV,SAAS,EAAI;AAC9B,cAAIA,SAAS,CAAC9B,IAAV,KAAmBf,KAAK,CAACkC,IAA7B,EAAmC;AACjCmB,YAAAA,MAAM,IAAIC,QAAV;AACD;;AACDA,UAAAA,QAAQ,IAAI,CAAZ;;AACA,cAAIA,QAAQ,KAAK,GAAjB,EAAsB;AACpBN,YAAAA,MAAM,CAACtB,SAAP,CAAiB2B,MAAjB;AACAA,YAAAA,MAAM,GAAG,CAAT;AACAC,YAAAA,QAAQ,GAAG,CAAX;AACD;AACF,SAVD;;AAWA,YAAIA,QAAQ,KAAK,CAAjB,EAAoB;AAClBN,UAAAA,MAAM,CAACtB,SAAP,CAAiB2B,MAAjB;AACD,SAhBa,CAiBd;AACA;AACA;;;AACAL,QAAAA,MAAM,CAACtB,SAAP,CAAiB,CAAjB,EApBc,CAoBO;AACrB;;AACAY,QAAAA,UAAU,CAACiB,OAAX,CAAmB,UAAAV,SAAS,EAAI;AAC9BG,UAAAA,MAAM,CAACtB,SAAP,CAAiBmB,SAAS,CAAC9B,IAA3B,EAD8B,CACI;;AAClCiC,UAAAA,MAAM,CAACtB,SAAP,CAAiB,CAAjB,EAF8B,CAET;AACtB,SAHD,EAtBc,CA0Bd;;AACAY,QAAAA,UAAU,CAACiB,OAAX,CAAmB,UAAAV,SAAS,EAAI;AAC9B,cAAIA,SAAS,CAAC9B,IAAV,KAAmBf,KAAK,CAACkC,IAA7B,EAAmC;AACjCW,YAAAA,SAAS,CAAC3B,MAAV,CAAiBG,IAAjB,CAAsB2B,MAAtB,EAA8BH,SAAS,CAACzC,KAAxC;AACD;AACF,SAJD;AAKD;;AACD,aAAO4C,MAAP;AACD;;;;;;AAGHQ,MAAM,CAACC,OAAP,GAAiBrB,OAAjB","sourcesContent":["'use strict';\n\nconst CursorType = require('../constants/cursor');\nconst CommandCodes = require('../constants/commands');\nconst Types = require('../constants/types');\nconst Packet = require('../packets/packet');\nconst CharsetToEncoding = require('../constants/charset_encodings.js');\n\nfunction isJSON(value) {\n  return (\n    Array.isArray(value) ||\n    value.constructor === Object ||\n    (typeof value.toJSON === 'function' && !Buffer.isBuffer(value))\n  );\n}\n\n/**\n * Converts a value to an object describing type, String/Buffer representation and length\n * @param {*} value\n */\nfunction toParameter(value, encoding, timezone) {\n  let type = Types.VAR_STRING;\n  let length;\n  let writer = function(value) {\n    // eslint-disable-next-line no-invalid-this\n    return Packet.prototype.writeLengthCodedString.call(this, value, encoding);\n  };\n  if (value !== null) {\n    switch (typeof value) {\n      case 'undefined':\n        throw new TypeError('Bind parameters must not contain undefined');\n\n      case 'number':\n        type = Types.DOUBLE;\n        length = 8;\n        writer = Packet.prototype.writeDouble;\n        break;\n\n      case 'boolean':\n        value = value | 0;\n        type = Types.TINY;\n        length = 1;\n        writer = Packet.prototype.writeInt8;\n        break;\n\n      case 'object':\n        if (Object.prototype.toString.call(value) === '[object Date]') {\n          type = Types.DATETIME;\n          length = 12;\n          writer = function(value) {\n            // eslint-disable-next-line no-invalid-this\n            return Packet.prototype.writeDate.call(this, value, timezone);\n          };\n        } else if (isJSON(value)) {\n          value = JSON.stringify(value);\n          type = Types.JSON;\n        } else if (Buffer.isBuffer(value)) {\n          length = Packet.lengthCodedNumberLength(value.length) + value.length;\n          writer = Packet.prototype.writeLengthCodedBuffer;\n        }\n        break;\n\n      default:\n        value = value.toString();\n    }\n  } else {\n    value = '';\n    type = Types.NULL;\n  }\n  if (!length) {\n    length = Packet.lengthCodedStringLength(value, encoding);\n  }\n  return { value, type, length, writer };\n}\n\nclass Execute {\n  constructor(id, parameters, charsetNumber, timezone) {\n    this.id = id;\n    this.parameters = parameters;\n    this.encoding = CharsetToEncoding[charsetNumber];\n    this.timezone = timezone;\n  }\n\n  toPacket() {\n    // TODO: don't try to calculate packet length in advance, allocate some big buffer in advance (header + 256 bytes?)\n    // and copy + reallocate if not enough\n    // 0 + 4 - length, seqId\n    // 4 + 1 - COM_EXECUTE\n    // 5 + 4 - stmtId\n    // 9 + 1 - flags\n    // 10 + 4 - iteration-count (always 1)\n    let length = 14;\n    let parameters;\n    if (this.parameters && this.parameters.length > 0) {\n      length += Math.floor((this.parameters.length + 7) / 8);\n      length += 1; // new-params-bound-flag\n      length += 2 * this.parameters.length; // type byte for each parameter if new-params-bound-flag is set\n      parameters = this.parameters.map(value =>\n        toParameter(value, this.encoding, this.timezone)\n      );\n      length += parameters.reduce(\n        (accumulator, parameter) => accumulator + parameter.length,\n        0\n      );\n    }\n    const buffer = Buffer.allocUnsafe(length);\n    const packet = new Packet(0, buffer, 0, length);\n    packet.offset = 4;\n    packet.writeInt8(CommandCodes.STMT_EXECUTE);\n    packet.writeInt32(this.id);\n    packet.writeInt8(CursorType.NO_CURSOR); // flags\n    packet.writeInt32(1); // iteration-count, always 1\n    if (parameters) {\n      let bitmap = 0;\n      let bitValue = 1;\n      parameters.forEach(parameter => {\n        if (parameter.type === Types.NULL) {\n          bitmap += bitValue;\n        }\n        bitValue *= 2;\n        if (bitValue === 256) {\n          packet.writeInt8(bitmap);\n          bitmap = 0;\n          bitValue = 1;\n        }\n      });\n      if (bitValue !== 1) {\n        packet.writeInt8(bitmap);\n      }\n      // TODO: explain meaning of the flag\n      // afaik, if set n*2 bytes with type of parameter are sent before parameters\n      // if not, previous execution types are used (TODO prooflink)\n      packet.writeInt8(1); // new-params-bound-flag\n      // Write parameter types\n      parameters.forEach(parameter => {\n        packet.writeInt8(parameter.type); // field type\n        packet.writeInt8(0); // parameter flag\n      });\n      // Write parameter values\n      parameters.forEach(parameter => {\n        if (parameter.type !== Types.NULL) {\n          parameter.writer.call(packet, parameter.value);\n        }\n      });\n    }\n    return packet;\n  }\n}\n\nmodule.exports = Execute;\n"]},"metadata":{},"sourceType":"script"}