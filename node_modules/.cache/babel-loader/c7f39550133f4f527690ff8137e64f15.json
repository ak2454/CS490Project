{"ast":null,"code":"'use strict';\n\nvar _classCallCheck = require(\"/root/Test/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/root/Test/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar Packet = require('./packets/packet.js');\n\nvar MAX_PACKET_LENGTH = 16777215;\n\nfunction readPacketLength(b, off) {\n  var b0 = b[off];\n  var b1 = b[off + 1];\n  var b2 = b[off + 2];\n\n  if (b1 + b2 === 0) {\n    return b0;\n  }\n\n  return b0 + (b1 << 8) + (b2 << 16);\n}\n\nvar PacketParser = /*#__PURE__*/function () {\n  function PacketParser(onPacket, packetHeaderLength) {\n    _classCallCheck(this, PacketParser);\n\n    // 4 for normal packets, 7 for comprssed protocol packets\n    if (typeof packetHeaderLength === 'undefined') {\n      packetHeaderLength = 4;\n    } // array of last payload chunks\n    // only used when current payload is not complete\n\n\n    this.buffer = []; // total length of chunks on buffer\n\n    this.bufferLength = 0;\n    this.packetHeaderLength = packetHeaderLength; // incomplete header state: number of header bytes received\n\n    this.headerLen = 0; // expected payload length\n\n    this.length = 0;\n    this.largePacketParts = [];\n    this.firstPacketSequenceId = 0;\n    this.onPacket = onPacket;\n    this.execute = PacketParser.prototype.executeStart;\n    this._flushLargePacket = packetHeaderLength === 7 ? this._flushLargePacket7 : this._flushLargePacket4;\n  }\n\n  _createClass(PacketParser, [{\n    key: \"_flushLargePacket4\",\n    value: function _flushLargePacket4() {\n      var numPackets = this.largePacketParts.length;\n      this.largePacketParts.unshift(Buffer.from([0, 0, 0, 0])); // insert header\n\n      var body = Buffer.concat(this.largePacketParts);\n      var packet = new Packet(this.firstPacketSequenceId, body, 0, body.length);\n      this.largePacketParts.length = 0;\n      packet.numPackets = numPackets;\n      this.onPacket(packet);\n    }\n  }, {\n    key: \"_flushLargePacket7\",\n    value: function _flushLargePacket7() {\n      var numPackets = this.largePacketParts.length;\n      this.largePacketParts.unshift(Buffer.from([0, 0, 0, 0, 0, 0, 0])); // insert header\n\n      var body = Buffer.concat(this.largePacketParts);\n      this.largePacketParts.length = 0;\n      var packet = new Packet(this.firstPacketSequenceId, body, 0, body.length);\n      packet.numPackets = numPackets;\n      this.onPacket(packet);\n    }\n  }, {\n    key: \"executeStart\",\n    value: function executeStart(chunk) {\n      var start = 0;\n      var end = chunk.length;\n\n      while (end - start >= 3) {\n        this.length = readPacketLength(chunk, start);\n\n        if (end - start >= this.length + this.packetHeaderLength) {\n          // at least one full packet\n          var sequenceId = chunk[start + 3];\n\n          if (this.length < MAX_PACKET_LENGTH && this.largePacketParts.length === 0) {\n            this.onPacket(new Packet(sequenceId, chunk, start, start + this.packetHeaderLength + this.length));\n          } else {\n            // first large packet - remember it's id\n            if (this.largePacketParts.length === 0) {\n              this.firstPacketSequenceId = sequenceId;\n            }\n\n            this.largePacketParts.push(chunk.slice(start + this.packetHeaderLength, start + this.packetHeaderLength + this.length));\n\n            if (this.length < MAX_PACKET_LENGTH) {\n              this._flushLargePacket();\n            }\n          }\n\n          start += this.packetHeaderLength + this.length;\n        } else {\n          // payload is incomplete\n          this.buffer = [chunk.slice(start + 3, end)];\n          this.bufferLength = end - start - 3;\n          this.execute = PacketParser.prototype.executePayload;\n          return;\n        }\n      }\n\n      if (end - start > 0) {\n        // there is start of length header, but it's not full 3 bytes\n        this.headerLen = end - start; // 1 or 2 bytes\n\n        this.length = chunk[start];\n\n        if (this.headerLen === 2) {\n          this.length = chunk[start] + (chunk[start + 1] << 8);\n          this.execute = PacketParser.prototype.executeHeader3;\n        } else {\n          this.execute = PacketParser.prototype.executeHeader2;\n        }\n      }\n    }\n  }, {\n    key: \"executePayload\",\n    value: function executePayload(chunk) {\n      var start = 0;\n      var end = chunk.length;\n      var remainingPayload = this.length - this.bufferLength + this.packetHeaderLength - 3;\n\n      if (end - start >= remainingPayload) {\n        // last chunk for payload\n        var payload = Buffer.allocUnsafe(this.length + this.packetHeaderLength);\n        var offset = 3;\n\n        for (var i = 0; i < this.buffer.length; ++i) {\n          this.buffer[i].copy(payload, offset);\n          offset += this.buffer[i].length;\n        }\n\n        chunk.copy(payload, offset, start, start + remainingPayload);\n        var sequenceId = payload[3];\n\n        if (this.length < MAX_PACKET_LENGTH && this.largePacketParts.length === 0) {\n          this.onPacket(new Packet(sequenceId, payload, 0, this.length + this.packetHeaderLength));\n        } else {\n          // first large packet - remember it's id\n          if (this.largePacketParts.length === 0) {\n            this.firstPacketSequenceId = sequenceId;\n          }\n\n          this.largePacketParts.push(payload.slice(this.packetHeaderLength, this.packetHeaderLength + this.length));\n\n          if (this.length < MAX_PACKET_LENGTH) {\n            this._flushLargePacket();\n          }\n        }\n\n        this.buffer = [];\n        this.bufferLength = 0;\n        this.execute = PacketParser.prototype.executeStart;\n        start += remainingPayload;\n\n        if (end - start > 0) {\n          return this.execute(chunk.slice(start, end));\n        }\n      } else {\n        this.buffer.push(chunk);\n        this.bufferLength += chunk.length;\n      }\n\n      return null;\n    }\n  }, {\n    key: \"executeHeader2\",\n    value: function executeHeader2(chunk) {\n      this.length += chunk[0] << 8;\n\n      if (chunk.length > 1) {\n        this.length += chunk[1] << 16;\n        this.execute = PacketParser.prototype.executePayload;\n        return this.executePayload(chunk.slice(2));\n      }\n\n      this.execute = PacketParser.prototype.executeHeader3;\n      return null;\n    }\n  }, {\n    key: \"executeHeader3\",\n    value: function executeHeader3(chunk) {\n      this.length += chunk[0] << 16;\n      this.execute = PacketParser.prototype.executePayload;\n      return this.executePayload(chunk.slice(1));\n    }\n  }]);\n\n  return PacketParser;\n}();\n\nmodule.exports = PacketParser;","map":{"version":3,"sources":["/root/Test/node_modules/mysql2/lib/packet_parser.js"],"names":["Packet","require","MAX_PACKET_LENGTH","readPacketLength","b","off","b0","b1","b2","PacketParser","onPacket","packetHeaderLength","buffer","bufferLength","headerLen","length","largePacketParts","firstPacketSequenceId","execute","prototype","executeStart","_flushLargePacket","_flushLargePacket7","_flushLargePacket4","numPackets","unshift","Buffer","from","body","concat","packet","chunk","start","end","sequenceId","push","slice","executePayload","executeHeader3","executeHeader2","remainingPayload","payload","allocUnsafe","offset","i","copy","module","exports"],"mappings":"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","sourcesContent":["'use strict';\n\nconst Packet = require('./packets/packet.js');\n\nconst MAX_PACKET_LENGTH = 16777215;\n\nfunction readPacketLength(b, off) {\n  const b0 = b[off];\n  const b1 = b[off + 1];\n  const b2 = b[off + 2];\n  if (b1 + b2 === 0) {\n    return b0;\n  }\n  return b0 + (b1 << 8) + (b2 << 16);\n}\n\nclass PacketParser {\n  constructor(onPacket, packetHeaderLength) {\n    // 4 for normal packets, 7 for comprssed protocol packets\n    if (typeof packetHeaderLength === 'undefined') {\n      packetHeaderLength = 4;\n    }\n    // array of last payload chunks\n    // only used when current payload is not complete\n    this.buffer = [];\n    // total length of chunks on buffer\n    this.bufferLength = 0;\n    this.packetHeaderLength = packetHeaderLength;\n    // incomplete header state: number of header bytes received\n    this.headerLen = 0;\n    // expected payload length\n    this.length = 0;\n    this.largePacketParts = [];\n    this.firstPacketSequenceId = 0;\n    this.onPacket = onPacket;\n    this.execute = PacketParser.prototype.executeStart;\n    this._flushLargePacket =\n      packetHeaderLength === 7\n        ? this._flushLargePacket7\n        : this._flushLargePacket4;\n  }\n\n  _flushLargePacket4() {\n    const numPackets = this.largePacketParts.length;\n    this.largePacketParts.unshift(Buffer.from([0, 0, 0, 0])); // insert header\n    const body = Buffer.concat(this.largePacketParts);\n    const packet = new Packet(this.firstPacketSequenceId, body, 0, body.length);\n    this.largePacketParts.length = 0;\n    packet.numPackets = numPackets;\n    this.onPacket(packet);\n  }\n\n  _flushLargePacket7() {\n    const numPackets = this.largePacketParts.length;\n    this.largePacketParts.unshift(Buffer.from([0, 0, 0, 0, 0, 0, 0])); // insert header\n    const body = Buffer.concat(this.largePacketParts);\n    this.largePacketParts.length = 0;\n    const packet = new Packet(this.firstPacketSequenceId, body, 0, body.length);\n    packet.numPackets = numPackets;\n    this.onPacket(packet);\n  }\n\n  executeStart(chunk) {\n    let start = 0;\n    const end = chunk.length;\n    while (end - start >= 3) {\n      this.length = readPacketLength(chunk, start);\n      if (end - start >= this.length + this.packetHeaderLength) {\n        // at least one full packet\n        const sequenceId = chunk[start + 3];\n        if (\n          this.length < MAX_PACKET_LENGTH &&\n          this.largePacketParts.length === 0\n        ) {\n          this.onPacket(\n            new Packet(\n              sequenceId,\n              chunk,\n              start,\n              start + this.packetHeaderLength + this.length\n            )\n          );\n        } else {\n          // first large packet - remember it's id\n          if (this.largePacketParts.length === 0) {\n            this.firstPacketSequenceId = sequenceId;\n          }\n          this.largePacketParts.push(\n            chunk.slice(\n              start + this.packetHeaderLength,\n              start + this.packetHeaderLength + this.length\n            )\n          );\n          if (this.length < MAX_PACKET_LENGTH) {\n            this._flushLargePacket();\n          }\n        }\n        start += this.packetHeaderLength + this.length;\n      } else {\n        // payload is incomplete\n        this.buffer = [chunk.slice(start + 3, end)];\n        this.bufferLength = end - start - 3;\n        this.execute = PacketParser.prototype.executePayload;\n        return;\n      }\n    }\n    if (end - start > 0) {\n      // there is start of length header, but it's not full 3 bytes\n      this.headerLen = end - start; // 1 or 2 bytes\n      this.length = chunk[start];\n      if (this.headerLen === 2) {\n        this.length = chunk[start] + (chunk[start + 1] << 8);\n        this.execute = PacketParser.prototype.executeHeader3;\n      } else {\n        this.execute = PacketParser.prototype.executeHeader2;\n      }\n    }\n  }\n\n  executePayload(chunk) {\n    let start = 0;\n    const end = chunk.length;\n    const remainingPayload =\n      this.length - this.bufferLength + this.packetHeaderLength - 3;\n    if (end - start >= remainingPayload) {\n      // last chunk for payload\n      const payload = Buffer.allocUnsafe(this.length + this.packetHeaderLength);\n      let offset = 3;\n      for (let i = 0; i < this.buffer.length; ++i) {\n        this.buffer[i].copy(payload, offset);\n        offset += this.buffer[i].length;\n      }\n      chunk.copy(payload, offset, start, start + remainingPayload);\n      const sequenceId = payload[3];\n      if (\n        this.length < MAX_PACKET_LENGTH &&\n        this.largePacketParts.length === 0\n      ) {\n        this.onPacket(\n          new Packet(\n            sequenceId,\n            payload,\n            0,\n            this.length + this.packetHeaderLength\n          )\n        );\n      } else {\n        // first large packet - remember it's id\n        if (this.largePacketParts.length === 0) {\n          this.firstPacketSequenceId = sequenceId;\n        }\n        this.largePacketParts.push(\n          payload.slice(\n            this.packetHeaderLength,\n            this.packetHeaderLength + this.length\n          )\n        );\n        if (this.length < MAX_PACKET_LENGTH) {\n          this._flushLargePacket();\n        }\n      }\n      this.buffer = [];\n      this.bufferLength = 0;\n      this.execute = PacketParser.prototype.executeStart;\n      start += remainingPayload;\n      if (end - start > 0) {\n        return this.execute(chunk.slice(start, end));\n      }\n    } else {\n      this.buffer.push(chunk);\n      this.bufferLength += chunk.length;\n    }\n    return null;\n  }\n\n  executeHeader2(chunk) {\n    this.length += chunk[0] << 8;\n    if (chunk.length > 1) {\n      this.length += chunk[1] << 16;\n      this.execute = PacketParser.prototype.executePayload;\n      return this.executePayload(chunk.slice(2));\n    } \n    this.execute = PacketParser.prototype.executeHeader3;\n    \n    return null;\n  }\n\n  executeHeader3(chunk) {\n    this.length += chunk[0] << 16;\n    this.execute = PacketParser.prototype.executePayload;\n    return this.executePayload(chunk.slice(1));\n  }\n}\n\nmodule.exports = PacketParser;\n"]},"metadata":{},"sourceType":"script"}