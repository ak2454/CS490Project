{"ast":null,"code":"// This file was modified by Oracle on June 1, 2021.\n// A comment describing some changes in the strict default SQL mode regarding\n// non-standard dates was introduced.\n// Modifications copyright (c) 2021, Oracle and/or its affiliates.\n'use strict';\n\nvar _classCallCheck = require(\"/root/Test/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/root/Test/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar ErrorCodeToName = require('../constants/errors.js');\n\nvar NativeBuffer = require('buffer').Buffer;\n\nvar Long = require('long');\n\nvar StringParser = require('../parsers/string.js');\n\nvar INVALID_DATE = new Date(NaN); // this is nearly duplicate of previous function so generated code is not slower\n// due to \"if (dateStrings)\" branching\n\nvar pad = '000000000000';\n\nfunction leftPad(num, value) {\n  var s = value.toString(); // if we don't need to pad\n\n  if (s.length >= num) {\n    return s;\n  }\n\n  return (pad + s).slice(-num);\n} // The whole reason parse* function below exist\n// is because String creation is relatively expensive (at least with V8), and if we have\n// a buffer with \"12345\" content ideally we would like to bypass intermediate\n// \"12345\" string creation and directly build 12345 number out of\n// <Buffer 31 32 33 34 35> data.\n// In my benchmarks the difference is ~25M 8-digit numbers per second vs\n// 4.5 M using Number(packet.readLengthCodedString())\n// not used when size is close to max precision as series of *10 accumulate error\n// and approximate result mihgt be diffreent from (approximate as well) Number(bigNumStringValue))\n// In the futire node version if speed difference is smaller parse* functions might be removed\n// don't consider them as Packet public API\n\n\nvar minus = '-'.charCodeAt(0);\nvar plus = '+'.charCodeAt(0); // TODO: handle E notation\n\nvar dot = '.'.charCodeAt(0);\nvar exponent = 'e'.charCodeAt(0);\nvar exponentCapital = 'E'.charCodeAt(0);\n\nvar Packet = /*#__PURE__*/function () {\n  function Packet(id, buffer, start, end) {\n    _classCallCheck(this, Packet);\n\n    // hot path, enable checks when testing only\n    // if (!Buffer.isBuffer(buffer) || typeof start == 'undefined' || typeof end == 'undefined')\n    //  throw new Error('invalid packet');\n    this.sequenceId = id;\n    this.numPackets = 1;\n    this.buffer = buffer;\n    this.start = start;\n    this.offset = start + 4;\n    this.end = end;\n  } // ==============================\n  // readers\n  // ==============================\n\n\n  _createClass(Packet, [{\n    key: \"reset\",\n    value: function reset() {\n      this.offset = this.start + 4;\n    }\n  }, {\n    key: \"length\",\n    value: function length() {\n      return this.end - this.start;\n    }\n  }, {\n    key: \"slice\",\n    value: function slice() {\n      return this.buffer.slice(this.start, this.end);\n    }\n  }, {\n    key: \"dump\",\n    value: function dump() {\n      // eslint-disable-next-line no-console\n      console.log([this.buffer.asciiSlice(this.start, this.end)], this.buffer.slice(this.start, this.end), this.length(), this.sequenceId);\n    }\n  }, {\n    key: \"haveMoreData\",\n    value: function haveMoreData() {\n      return this.end > this.offset;\n    }\n  }, {\n    key: \"skip\",\n    value: function skip(num) {\n      this.offset += num;\n    }\n  }, {\n    key: \"readInt8\",\n    value: function readInt8() {\n      return this.buffer[this.offset++];\n    }\n  }, {\n    key: \"readInt16\",\n    value: function readInt16() {\n      this.offset += 2;\n      return this.buffer.readUInt16LE(this.offset - 2);\n    }\n  }, {\n    key: \"readInt24\",\n    value: function readInt24() {\n      return this.readInt16() + (this.readInt8() << 16);\n    }\n  }, {\n    key: \"readInt32\",\n    value: function readInt32() {\n      this.offset += 4;\n      return this.buffer.readUInt32LE(this.offset - 4);\n    }\n  }, {\n    key: \"readSInt8\",\n    value: function readSInt8() {\n      return this.buffer.readInt8(this.offset++);\n    }\n  }, {\n    key: \"readSInt16\",\n    value: function readSInt16() {\n      this.offset += 2;\n      return this.buffer.readInt16LE(this.offset - 2);\n    }\n  }, {\n    key: \"readSInt32\",\n    value: function readSInt32() {\n      this.offset += 4;\n      return this.buffer.readInt32LE(this.offset - 4);\n    }\n  }, {\n    key: \"readInt64JSNumber\",\n    value: function readInt64JSNumber() {\n      var word0 = this.readInt32();\n      var word1 = this.readInt32();\n      var l = new Long(word0, word1, true);\n      return l.toNumber();\n    }\n  }, {\n    key: \"readSInt64JSNumber\",\n    value: function readSInt64JSNumber() {\n      var word0 = this.readInt32();\n      var word1 = this.readInt32();\n\n      if (!(word1 & 0x80000000)) {\n        return word0 + 0x100000000 * word1;\n      }\n\n      var l = new Long(word0, word1, false);\n      return l.toNumber();\n    }\n  }, {\n    key: \"readInt64String\",\n    value: function readInt64String() {\n      var word0 = this.readInt32();\n      var word1 = this.readInt32();\n      var res = new Long(word0, word1, true);\n      return res.toString();\n    }\n  }, {\n    key: \"readSInt64String\",\n    value: function readSInt64String() {\n      var word0 = this.readInt32();\n      var word1 = this.readInt32();\n      var res = new Long(word0, word1, false);\n      return res.toString();\n    }\n  }, {\n    key: \"readInt64\",\n    value: function readInt64() {\n      var word0 = this.readInt32();\n      var word1 = this.readInt32();\n      var res = new Long(word0, word1, true);\n      var resNumber = res.toNumber();\n      var resString = res.toString();\n      res = resNumber.toString() === resString ? resNumber : resString;\n      return res;\n    }\n  }, {\n    key: \"readSInt64\",\n    value: function readSInt64() {\n      var word0 = this.readInt32();\n      var word1 = this.readInt32();\n      var res = new Long(word0, word1, false);\n      var resNumber = res.toNumber();\n      var resString = res.toString();\n      res = resNumber.toString() === resString ? resNumber : resString;\n      return res;\n    }\n  }, {\n    key: \"isEOF\",\n    value: function isEOF() {\n      return this.buffer[this.offset] === 0xfe && this.length() < 13;\n    }\n  }, {\n    key: \"eofStatusFlags\",\n    value: function eofStatusFlags() {\n      return this.buffer.readInt16LE(this.offset + 3);\n    }\n  }, {\n    key: \"eofWarningCount\",\n    value: function eofWarningCount() {\n      return this.buffer.readInt16LE(this.offset + 1);\n    }\n  }, {\n    key: \"readLengthCodedNumber\",\n    value: function readLengthCodedNumber(bigNumberStrings, signed) {\n      var byte1 = this.buffer[this.offset++];\n\n      if (byte1 < 251) {\n        return byte1;\n      }\n\n      return this.readLengthCodedNumberExt(byte1, bigNumberStrings, signed);\n    }\n  }, {\n    key: \"readLengthCodedNumberSigned\",\n    value: function readLengthCodedNumberSigned(bigNumberStrings) {\n      return this.readLengthCodedNumber(bigNumberStrings, true);\n    }\n  }, {\n    key: \"readLengthCodedNumberExt\",\n    value: function readLengthCodedNumberExt(tag, bigNumberStrings, signed) {\n      var word0, word1;\n      var res;\n\n      if (tag === 0xfb) {\n        return null;\n      }\n\n      if (tag === 0xfc) {\n        return this.readInt8() + (this.readInt8() << 8);\n      }\n\n      if (tag === 0xfd) {\n        return this.readInt8() + (this.readInt8() << 8) + (this.readInt8() << 16);\n      }\n\n      if (tag === 0xfe) {\n        // TODO: check version\n        // Up to MySQL 3.22, 0xfe was followed by a 4-byte integer.\n        word0 = this.readInt32();\n        word1 = this.readInt32();\n\n        if (word1 === 0) {\n          return word0; // don't convert to float if possible\n        }\n\n        if (word1 < 2097152) {\n          // max exact float point int, 2^52 / 2^32\n          return word1 * 0x100000000 + word0;\n        }\n\n        res = new Long(word0, word1, !signed); // Long need unsigned\n\n        var resNumber = res.toNumber();\n        var resString = res.toString();\n        res = resNumber.toString() === resString ? resNumber : resString;\n        return bigNumberStrings ? resString : res;\n      } // eslint-disable-next-line no-console\n\n\n      console.trace();\n      throw new Error(\"Should not reach here: \".concat(tag));\n    }\n  }, {\n    key: \"readFloat\",\n    value: function readFloat() {\n      var res = this.buffer.readFloatLE(this.offset);\n      this.offset += 4;\n      return res;\n    }\n  }, {\n    key: \"readDouble\",\n    value: function readDouble() {\n      var res = this.buffer.readDoubleLE(this.offset);\n      this.offset += 8;\n      return res;\n    }\n  }, {\n    key: \"readBuffer\",\n    value: function readBuffer(len) {\n      if (typeof len === 'undefined') {\n        len = this.end - this.offset;\n      }\n\n      this.offset += len;\n      return this.buffer.slice(this.offset - len, this.offset);\n    } // DATE, DATETIME and TIMESTAMP\n\n  }, {\n    key: \"readDateTime\",\n    value: function readDateTime(timezone) {\n      if (!timezone || timezone === 'Z' || timezone === 'local') {\n        var length = this.readInt8();\n\n        if (length === 0xfb) {\n          return null;\n        }\n\n        var y = 0;\n        var m = 0;\n        var d = 0;\n        var H = 0;\n        var M = 0;\n        var S = 0;\n        var ms = 0;\n\n        if (length > 3) {\n          y = this.readInt16();\n          m = this.readInt8();\n          d = this.readInt8();\n        }\n\n        if (length > 6) {\n          H = this.readInt8();\n          M = this.readInt8();\n          S = this.readInt8();\n        }\n\n        if (length > 10) {\n          ms = this.readInt32() / 1000;\n        } // NO_ZERO_DATE mode and NO_ZERO_IN_DATE mode are part of the strict\n        // default SQL mode used by MySQL 8.0. This means that non-standard\n        // dates like '0000-00-00' become NULL. For older versions and other\n        // possible MySQL flavours we still need to account for the\n        // non-standard behaviour.\n\n\n        if (y + m + d + H + M + S + ms === 0) {\n          return INVALID_DATE;\n        }\n\n        if (timezone === 'Z') {\n          return new Date(Date.UTC(y, m - 1, d, H, M, S, ms));\n        }\n\n        return new Date(y, m - 1, d, H, M, S, ms);\n      }\n\n      var str = this.readDateTimeString(6, 'T');\n\n      if (str.length === 10) {\n        str += 'T00:00:00';\n      }\n\n      return new Date(str + timezone);\n    }\n  }, {\n    key: \"readDateTimeString\",\n    value: function readDateTimeString(decimals, timeSep) {\n      var length = this.readInt8();\n      var y = 0;\n      var m = 0;\n      var d = 0;\n      var H = 0;\n      var M = 0;\n      var S = 0;\n      var ms = 0;\n      var str;\n\n      if (length > 3) {\n        y = this.readInt16();\n        m = this.readInt8();\n        d = this.readInt8();\n        str = [leftPad(4, y), leftPad(2, m), leftPad(2, d)].join('-');\n      }\n\n      if (length > 6) {\n        H = this.readInt8();\n        M = this.readInt8();\n        S = this.readInt8();\n        str += \"\".concat(timeSep || ' ').concat([leftPad(2, H), leftPad(2, M), leftPad(2, S)].join(':'));\n      }\n\n      if (length > 10) {\n        ms = this.readInt32();\n        str += '.';\n\n        if (decimals) {\n          ms = leftPad(6, ms);\n\n          if (ms.length > decimals) {\n            ms = ms.substring(0, decimals); // rounding is done at the MySQL side, only 0 are here\n          }\n        }\n\n        str += ms;\n      }\n\n      return str;\n    } // TIME - value as a string, Can be negative\n\n  }, {\n    key: \"readTimeString\",\n    value: function readTimeString(convertTtoMs) {\n      var length = this.readInt8();\n\n      if (length === 0) {\n        return '00:00:00';\n      }\n\n      var sign = this.readInt8() ? -1 : 1; // 'isNegative' flag byte\n\n      var d = 0;\n      var H = 0;\n      var M = 0;\n      var S = 0;\n      var ms = 0;\n\n      if (length > 6) {\n        d = this.readInt32();\n        H = this.readInt8();\n        M = this.readInt8();\n        S = this.readInt8();\n      }\n\n      if (length > 10) {\n        ms = this.readInt32();\n      }\n\n      if (convertTtoMs) {\n        H += d * 24;\n        M += H * 60;\n        S += M * 60;\n        ms += S * 1000;\n        ms *= sign;\n        return ms;\n      }\n\n      return (sign === -1 ? '-' : '') + [d ? d * 24 + H : H, leftPad(2, M), leftPad(2, S)].join(':') + (ms ? \".\".concat(ms) : '');\n    }\n  }, {\n    key: \"readLengthCodedString\",\n    value: function readLengthCodedString(encoding) {\n      var len = this.readLengthCodedNumber(); // TODO: check manually first byte here to avoid polymorphic return type?\n\n      if (len === null) {\n        return null;\n      }\n\n      this.offset += len; // TODO: Use characterSetCode to get proper encoding\n      // https://github.com/sidorares/node-mysql2/pull/374\n\n      return StringParser.decode(this.buffer.slice(this.offset - len, this.offset), encoding);\n    }\n  }, {\n    key: \"readLengthCodedBuffer\",\n    value: function readLengthCodedBuffer() {\n      var len = this.readLengthCodedNumber();\n\n      if (len === null) {\n        return null;\n      }\n\n      return this.readBuffer(len);\n    }\n  }, {\n    key: \"readNullTerminatedString\",\n    value: function readNullTerminatedString(encoding) {\n      var start = this.offset;\n      var end = this.offset;\n\n      while (this.buffer[end]) {\n        end = end + 1; // TODO: handle OOB check\n      }\n\n      this.offset = end + 1;\n      return StringParser.decode(this.buffer.slice(start, end), encoding);\n    } // TODO reuse?\n\n  }, {\n    key: \"readString\",\n    value: function readString(len, encoding) {\n      if (typeof len === 'string' && typeof encoding === 'undefined') {\n        encoding = len;\n        len = undefined;\n      }\n\n      if (typeof len === 'undefined') {\n        len = this.end - this.offset;\n      }\n\n      this.offset += len;\n      return StringParser.decode(this.buffer.slice(this.offset - len, this.offset), encoding);\n    }\n  }, {\n    key: \"parseInt\",\n    value: function (_parseInt) {\n      function parseInt(_x, _x2) {\n        return _parseInt.apply(this, arguments);\n      }\n\n      parseInt.toString = function () {\n        return _parseInt.toString();\n      };\n\n      return parseInt;\n    }(function (len, supportBigNumbers) {\n      if (len === null) {\n        return null;\n      }\n\n      if (len >= 14 && !supportBigNumbers) {\n        var s = this.buffer.toString('ascii', this.offset, this.offset + len);\n        this.offset += len;\n        return Number(s);\n      }\n\n      var result = 0;\n      var start = this.offset;\n      var end = this.offset + len;\n      var sign = 1;\n\n      if (len === 0) {\n        return 0; // TODO: assert? exception?\n      }\n\n      if (this.buffer[this.offset] === minus) {\n        this.offset++;\n        sign = -1;\n      } // max precise int is 9007199254740992\n\n\n      var str;\n      var numDigits = end - this.offset;\n\n      if (supportBigNumbers) {\n        if (numDigits >= 15) {\n          str = this.readString(end - this.offset, 'binary');\n          result = parseInt(str, 10);\n\n          if (result.toString() === str) {\n            return sign * result;\n          }\n\n          return sign === -1 ? \"-\".concat(str) : str;\n        }\n\n        if (numDigits > 16) {\n          str = this.readString(end - this.offset);\n          return sign === -1 ? \"-\".concat(str) : str;\n        }\n      }\n\n      if (this.buffer[this.offset] === plus) {\n        this.offset++; // just ignore\n      }\n\n      while (this.offset < end) {\n        result *= 10;\n        result += this.buffer[this.offset] - 48;\n        this.offset++;\n      }\n\n      var num = result * sign;\n\n      if (!supportBigNumbers) {\n        return num;\n      }\n\n      str = this.buffer.toString('ascii', start, end);\n\n      if (num.toString() === str) {\n        return num;\n      }\n\n      return str;\n    } // note that if value of inputNumberAsString is bigger than MAX_SAFE_INTEGER\n    // ( or smaller than MIN_SAFE_INTEGER ) the parseIntNoBigCheck result might be\n    // different from what you would get from Number(inputNumberAsString)\n    // String(parseIntNoBigCheck) <> String(Number(inputNumberAsString)) <> inputNumberAsString\n    )\n  }, {\n    key: \"parseIntNoBigCheck\",\n    value: function parseIntNoBigCheck(len) {\n      if (len === null) {\n        return null;\n      }\n\n      var result = 0;\n      var end = this.offset + len;\n      var sign = 1;\n\n      if (len === 0) {\n        return 0; // TODO: assert? exception?\n      }\n\n      if (this.buffer[this.offset] === minus) {\n        this.offset++;\n        sign = -1;\n      }\n\n      if (this.buffer[this.offset] === plus) {\n        this.offset++; // just ignore\n      }\n\n      while (this.offset < end) {\n        result *= 10;\n        result += this.buffer[this.offset] - 48;\n        this.offset++;\n      }\n\n      return result * sign;\n    } // copy-paste from https://github.com/mysqljs/mysql/blob/master/lib/protocol/Parser.js\n\n  }, {\n    key: \"parseGeometryValue\",\n    value: function parseGeometryValue() {\n      var buffer = this.readLengthCodedBuffer();\n      var offset = 4;\n\n      if (buffer === null || !buffer.length) {\n        return null;\n      }\n\n      function parseGeometry() {\n        var x, y, i, j, numPoints, line;\n        var result = null;\n        var byteOrder = buffer.readUInt8(offset);\n        offset += 1;\n        var wkbType = byteOrder ? buffer.readUInt32LE(offset) : buffer.readUInt32BE(offset);\n        offset += 4;\n\n        switch (wkbType) {\n          case 1:\n            // WKBPoint\n            x = byteOrder ? buffer.readDoubleLE(offset) : buffer.readDoubleBE(offset);\n            offset += 8;\n            y = byteOrder ? buffer.readDoubleLE(offset) : buffer.readDoubleBE(offset);\n            offset += 8;\n            result = {\n              x: x,\n              y: y\n            };\n            break;\n\n          case 2:\n            // WKBLineString\n            numPoints = byteOrder ? buffer.readUInt32LE(offset) : buffer.readUInt32BE(offset);\n            offset += 4;\n            result = [];\n\n            for (i = numPoints; i > 0; i--) {\n              x = byteOrder ? buffer.readDoubleLE(offset) : buffer.readDoubleBE(offset);\n              offset += 8;\n              y = byteOrder ? buffer.readDoubleLE(offset) : buffer.readDoubleBE(offset);\n              offset += 8;\n              result.push({\n                x: x,\n                y: y\n              });\n            }\n\n            break;\n\n          case 3:\n            // WKBPolygon\n            // eslint-disable-next-line no-case-declarations\n            var numRings = byteOrder ? buffer.readUInt32LE(offset) : buffer.readUInt32BE(offset);\n            offset += 4;\n            result = [];\n\n            for (i = numRings; i > 0; i--) {\n              numPoints = byteOrder ? buffer.readUInt32LE(offset) : buffer.readUInt32BE(offset);\n              offset += 4;\n              line = [];\n\n              for (j = numPoints; j > 0; j--) {\n                x = byteOrder ? buffer.readDoubleLE(offset) : buffer.readDoubleBE(offset);\n                offset += 8;\n                y = byteOrder ? buffer.readDoubleLE(offset) : buffer.readDoubleBE(offset);\n                offset += 8;\n                line.push({\n                  x: x,\n                  y: y\n                });\n              }\n\n              result.push(line);\n            }\n\n            break;\n\n          case 4: // WKBMultiPoint\n\n          case 5: // WKBMultiLineString\n\n          case 6: // WKBMultiPolygon\n\n          case 7:\n            // WKBGeometryCollection\n            // eslint-disable-next-line no-case-declarations\n            var num = byteOrder ? buffer.readUInt32LE(offset) : buffer.readUInt32BE(offset);\n            offset += 4;\n            result = [];\n\n            for (i = num; i > 0; i--) {\n              result.push(parseGeometry());\n            }\n\n            break;\n        }\n\n        return result;\n      }\n\n      return parseGeometry();\n    }\n  }, {\n    key: \"parseDate\",\n    value: function parseDate(timezone) {\n      var strLen = this.readLengthCodedNumber();\n\n      if (strLen === null) {\n        return null;\n      }\n\n      if (strLen !== 10) {\n        // we expect only YYYY-MM-DD here.\n        // if for some reason it's not the case return invalid date\n        return new Date(NaN);\n      }\n\n      var y = this.parseInt(4);\n      this.offset++; // -\n\n      var m = this.parseInt(2);\n      this.offset++; // -\n\n      var d = this.parseInt(2);\n\n      if (!timezone || timezone === 'local') {\n        return new Date(y, m - 1, d);\n      }\n\n      if (timezone === 'Z') {\n        return new Date(Date.UTC(y, m - 1, d));\n      }\n\n      return new Date(\"\".concat(leftPad(4, y), \"-\").concat(leftPad(2, m), \"-\").concat(leftPad(2, d), \"T00:00:00\").concat(timezone));\n    }\n  }, {\n    key: \"parseDateTime\",\n    value: function parseDateTime(timezone) {\n      var str = this.readLengthCodedString('binary');\n\n      if (str === null) {\n        return null;\n      }\n\n      if (!timezone || timezone === 'local') {\n        return new Date(str);\n      }\n\n      return new Date(\"\".concat(str).concat(timezone));\n    }\n  }, {\n    key: \"parseFloat\",\n    value: function parseFloat(len) {\n      if (len === null) {\n        return null;\n      }\n\n      var result = 0;\n      var end = this.offset + len;\n      var factor = 1;\n      var pastDot = false;\n      var charCode = 0;\n\n      if (len === 0) {\n        return 0; // TODO: assert? exception?\n      }\n\n      if (this.buffer[this.offset] === minus) {\n        this.offset++;\n        factor = -1;\n      }\n\n      if (this.buffer[this.offset] === plus) {\n        this.offset++; // just ignore\n      }\n\n      while (this.offset < end) {\n        charCode = this.buffer[this.offset];\n\n        if (charCode === dot) {\n          pastDot = true;\n          this.offset++;\n        } else if (charCode === exponent || charCode === exponentCapital) {\n          this.offset++;\n          var exponentValue = this.parseInt(end - this.offset);\n          return result / factor * Math.pow(10, exponentValue);\n        } else {\n          result *= 10;\n          result += this.buffer[this.offset] - 48;\n          this.offset++;\n\n          if (pastDot) {\n            factor = factor * 10;\n          }\n        }\n      }\n\n      return result / factor;\n    }\n  }, {\n    key: \"parseLengthCodedIntNoBigCheck\",\n    value: function parseLengthCodedIntNoBigCheck() {\n      return this.parseIntNoBigCheck(this.readLengthCodedNumber());\n    }\n  }, {\n    key: \"parseLengthCodedInt\",\n    value: function parseLengthCodedInt(supportBigNumbers) {\n      return this.parseInt(this.readLengthCodedNumber(), supportBigNumbers);\n    }\n  }, {\n    key: \"parseLengthCodedIntString\",\n    value: function parseLengthCodedIntString() {\n      return this.readLengthCodedString('binary');\n    }\n  }, {\n    key: \"parseLengthCodedFloat\",\n    value: function parseLengthCodedFloat() {\n      return this.parseFloat(this.readLengthCodedNumber());\n    }\n  }, {\n    key: \"peekByte\",\n    value: function peekByte() {\n      return this.buffer[this.offset];\n    } // OxFE is often used as \"Alt\" flag - not ok, not error.\n    // For example, it's first byte of AuthSwitchRequest\n\n  }, {\n    key: \"isAlt\",\n    value: function isAlt() {\n      return this.peekByte() === 0xfe;\n    }\n  }, {\n    key: \"isError\",\n    value: function isError() {\n      return this.peekByte() === 0xff;\n    }\n  }, {\n    key: \"asError\",\n    value: function asError(encoding) {\n      this.reset();\n      this.readInt8(); // fieldCount\n\n      var errorCode = this.readInt16();\n      var sqlState = '';\n\n      if (this.buffer[this.offset] === 0x23) {\n        this.skip(1);\n        sqlState = this.readBuffer(5).toString();\n      }\n\n      var message = this.readString(undefined, encoding);\n      var err = new Error(message);\n      err.code = ErrorCodeToName[errorCode];\n      err.errno = errorCode;\n      err.sqlState = sqlState;\n      err.sqlMessage = message;\n      return err;\n    }\n  }, {\n    key: \"writeInt32\",\n    value: function writeInt32(n) {\n      this.buffer.writeUInt32LE(n, this.offset);\n      this.offset += 4;\n    }\n  }, {\n    key: \"writeInt24\",\n    value: function writeInt24(n) {\n      this.writeInt8(n & 0xff);\n      this.writeInt16(n >> 8);\n    }\n  }, {\n    key: \"writeInt16\",\n    value: function writeInt16(n) {\n      this.buffer.writeUInt16LE(n, this.offset);\n      this.offset += 2;\n    }\n  }, {\n    key: \"writeInt8\",\n    value: function writeInt8(n) {\n      this.buffer.writeUInt8(n, this.offset);\n      this.offset++;\n    }\n  }, {\n    key: \"writeDouble\",\n    value: function writeDouble(n) {\n      this.buffer.writeDoubleLE(n, this.offset);\n      this.offset += 8;\n    }\n  }, {\n    key: \"writeBuffer\",\n    value: function writeBuffer(b) {\n      b.copy(this.buffer, this.offset);\n      this.offset += b.length;\n    }\n  }, {\n    key: \"writeNull\",\n    value: function writeNull() {\n      this.buffer[this.offset] = 0xfb;\n      this.offset++;\n    } // TODO: refactor following three?\n\n  }, {\n    key: \"writeNullTerminatedString\",\n    value: function writeNullTerminatedString(s, encoding) {\n      var buf = StringParser.encode(s, encoding);\n      this.buffer.length && buf.copy(this.buffer, this.offset);\n      this.offset += buf.length;\n      this.writeInt8(0);\n    }\n  }, {\n    key: \"writeString\",\n    value: function writeString(s, encoding) {\n      if (s === null) {\n        this.writeInt8(0xfb);\n        return;\n      }\n\n      if (s.length === 0) {\n        return;\n      } // const bytes = Buffer.byteLength(s, 'utf8');\n      // this.buffer.write(s, this.offset, bytes, 'utf8');\n      // this.offset += bytes;\n\n\n      var buf = StringParser.encode(s, encoding);\n      this.buffer.length && buf.copy(this.buffer, this.offset);\n      this.offset += buf.length;\n    }\n  }, {\n    key: \"writeLengthCodedString\",\n    value: function writeLengthCodedString(s, encoding) {\n      var buf = StringParser.encode(s, encoding);\n      this.writeLengthCodedNumber(buf.length);\n      this.buffer.length && buf.copy(this.buffer, this.offset);\n      this.offset += buf.length;\n    }\n  }, {\n    key: \"writeLengthCodedBuffer\",\n    value: function writeLengthCodedBuffer(b) {\n      this.writeLengthCodedNumber(b.length);\n      b.copy(this.buffer, this.offset);\n      this.offset += b.length;\n    }\n  }, {\n    key: \"writeLengthCodedNumber\",\n    value: function writeLengthCodedNumber(n) {\n      if (n < 0xfb) {\n        return this.writeInt8(n);\n      }\n\n      if (n < 0xffff) {\n        this.writeInt8(0xfc);\n        return this.writeInt16(n);\n      }\n\n      if (n < 0xffffff) {\n        this.writeInt8(0xfd);\n        return this.writeInt24(n);\n      }\n\n      if (n === null) {\n        return this.writeInt8(0xfb);\n      } // TODO: check that n is out of int precision\n\n\n      this.writeInt8(0xfe);\n      this.buffer.writeUInt32LE(n, this.offset);\n      this.offset += 4;\n      this.buffer.writeUInt32LE(n >> 32, this.offset);\n      this.offset += 4;\n      return this.offset;\n    }\n  }, {\n    key: \"writeDate\",\n    value: function writeDate(d, timezone) {\n      this.buffer.writeUInt8(11, this.offset);\n\n      if (!timezone || timezone === 'local') {\n        this.buffer.writeUInt16LE(d.getFullYear(), this.offset + 1);\n        this.buffer.writeUInt8(d.getMonth() + 1, this.offset + 3);\n        this.buffer.writeUInt8(d.getDate(), this.offset + 4);\n        this.buffer.writeUInt8(d.getHours(), this.offset + 5);\n        this.buffer.writeUInt8(d.getMinutes(), this.offset + 6);\n        this.buffer.writeUInt8(d.getSeconds(), this.offset + 7);\n        this.buffer.writeUInt32LE(d.getMilliseconds() * 1000, this.offset + 8);\n      } else {\n        if (timezone !== 'Z') {\n          var offset = (timezone[0] === '-' ? -1 : 1) * (parseInt(timezone.substring(1, 3), 10) * 60 + parseInt(timezone.substring(4), 10));\n\n          if (offset !== 0) {\n            d = new Date(d.getTime() + 60000 * offset);\n          }\n        }\n\n        this.buffer.writeUInt16LE(d.getUTCFullYear(), this.offset + 1);\n        this.buffer.writeUInt8(d.getUTCMonth() + 1, this.offset + 3);\n        this.buffer.writeUInt8(d.getUTCDate(), this.offset + 4);\n        this.buffer.writeUInt8(d.getUTCHours(), this.offset + 5);\n        this.buffer.writeUInt8(d.getUTCMinutes(), this.offset + 6);\n        this.buffer.writeUInt8(d.getUTCSeconds(), this.offset + 7);\n        this.buffer.writeUInt32LE(d.getUTCMilliseconds() * 1000, this.offset + 8);\n      }\n\n      this.offset += 12;\n    }\n  }, {\n    key: \"writeHeader\",\n    value: function writeHeader(sequenceId) {\n      var offset = this.offset;\n      this.offset = 0;\n      this.writeInt24(this.buffer.length - 4);\n      this.writeInt8(sequenceId);\n      this.offset = offset;\n    }\n  }, {\n    key: \"clone\",\n    value: function clone() {\n      return new Packet(this.sequenceId, this.buffer, this.start, this.end);\n    }\n  }, {\n    key: \"type\",\n    value: function type() {\n      if (this.isEOF()) {\n        return 'EOF';\n      }\n\n      if (this.isError()) {\n        return 'Error';\n      }\n\n      if (this.buffer[this.offset] === 0) {\n        return 'maybeOK'; // could be other packet types as well\n      }\n\n      return '';\n    }\n  }], [{\n    key: \"lengthCodedNumberLength\",\n    value: function lengthCodedNumberLength(n) {\n      if (n < 0xfb) {\n        return 1;\n      }\n\n      if (n < 0xffff) {\n        return 3;\n      }\n\n      if (n < 0xffffff) {\n        return 5;\n      }\n\n      return 9;\n    }\n  }, {\n    key: \"lengthCodedStringLength\",\n    value: function lengthCodedStringLength(str, encoding) {\n      var buf = StringParser.encode(str, encoding);\n      var slen = buf.length;\n      return Packet.lengthCodedNumberLength(slen) + slen;\n    }\n  }, {\n    key: \"MockBuffer\",\n    value: function MockBuffer() {\n      var noop = function noop() {};\n\n      var res = Buffer.alloc(0);\n\n      for (var op in NativeBuffer.prototype) {\n        if (typeof res[op] === 'function') {\n          res[op] = noop;\n        }\n      }\n\n      return res;\n    }\n  }]);\n\n  return Packet;\n}();\n\nmodule.exports = Packet;","map":{"version":3,"sources":["/root/Test/node_modules/mysql2/lib/packets/packet.js"],"names":["ErrorCodeToName","require","NativeBuffer","Buffer","Long","StringParser","INVALID_DATE","Date","NaN","pad","leftPad","num","value","s","toString","length","slice","minus","charCodeAt","plus","dot","exponent","exponentCapital","Packet","id","buffer","start","end","sequenceId","numPackets","offset","console","log","asciiSlice","readUInt16LE","readInt16","readInt8","readUInt32LE","readInt16LE","readInt32LE","word0","readInt32","word1","l","toNumber","res","resNumber","resString","bigNumberStrings","signed","byte1","readLengthCodedNumberExt","readLengthCodedNumber","tag","trace","Error","readFloatLE","readDoubleLE","len","timezone","y","m","d","H","M","S","ms","UTC","str","readDateTimeString","decimals","timeSep","join","substring","convertTtoMs","sign","encoding","decode","readBuffer","undefined","supportBigNumbers","Number","result","numDigits","readString","parseInt","readLengthCodedBuffer","parseGeometry","x","i","j","numPoints","line","byteOrder","readUInt8","wkbType","readUInt32BE","readDoubleBE","push","numRings","strLen","readLengthCodedString","factor","pastDot","charCode","exponentValue","Math","pow","parseIntNoBigCheck","parseFloat","peekByte","reset","errorCode","sqlState","skip","message","err","code","errno","sqlMessage","n","writeUInt32LE","writeInt8","writeInt16","writeUInt16LE","writeUInt8","writeDoubleLE","b","copy","buf","encode","writeLengthCodedNumber","writeInt24","getFullYear","getMonth","getDate","getHours","getMinutes","getSeconds","getMilliseconds","getTime","getUTCFullYear","getUTCMonth","getUTCDate","getUTCHours","getUTCMinutes","getUTCSeconds","getUTCMilliseconds","isEOF","isError","slen","lengthCodedNumberLength","noop","alloc","op","prototype","module","exports"],"mappings":"AAAA;AACA;AACA;AACA;AAEA;;;;;;AAEA,IAAMA,eAAe,GAAGC,OAAO,CAAC,wBAAD,CAA/B;;AACA,IAAMC,YAAY,GAAGD,OAAO,CAAC,QAAD,CAAP,CAAkBE,MAAvC;;AACA,IAAMC,IAAI,GAAGH,OAAO,CAAC,MAAD,CAApB;;AACA,IAAMI,YAAY,GAAGJ,OAAO,CAAC,sBAAD,CAA5B;;AAEA,IAAMK,YAAY,GAAG,IAAIC,IAAJ,CAASC,GAAT,CAArB,C,CAEA;AACA;;AACA,IAAMC,GAAG,GAAG,cAAZ;;AACA,SAASC,OAAT,CAAiBC,GAAjB,EAAsBC,KAAtB,EAA6B;AAC3B,MAAMC,CAAC,GAAGD,KAAK,CAACE,QAAN,EAAV,CAD2B,CAE3B;;AACA,MAAID,CAAC,CAACE,MAAF,IAAYJ,GAAhB,EAAqB;AACnB,WAAOE,CAAP;AACD;;AACD,SAAO,CAACJ,GAAG,GAAGI,CAAP,EAAUG,KAAV,CAAgB,CAACL,GAAjB,CAAP;AACD,C,CAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAEA,IAAMM,KAAK,GAAG,IAAIC,UAAJ,CAAe,CAAf,CAAd;AACA,IAAMC,IAAI,GAAG,IAAID,UAAJ,CAAe,CAAf,CAAb,C,CAEA;;AACA,IAAME,GAAG,GAAG,IAAIF,UAAJ,CAAe,CAAf,CAAZ;AACA,IAAMG,QAAQ,GAAG,IAAIH,UAAJ,CAAe,CAAf,CAAjB;AACA,IAAMI,eAAe,GAAG,IAAIJ,UAAJ,CAAe,CAAf,CAAxB;;IAEMK,M;AACJ,kBAAYC,EAAZ,EAAgBC,MAAhB,EAAwBC,KAAxB,EAA+BC,GAA/B,EAAoC;AAAA;;AAClC;AACA;AACA;AACA,SAAKC,UAAL,GAAkBJ,EAAlB;AACA,SAAKK,UAAL,GAAkB,CAAlB;AACA,SAAKJ,MAAL,GAAcA,MAAd;AACA,SAAKC,KAAL,GAAaA,KAAb;AACA,SAAKI,MAAL,GAAcJ,KAAK,GAAG,CAAtB;AACA,SAAKC,GAAL,GAAWA,GAAX;AACD,G,CAED;AACA;AACA;;;;;WACA,iBAAQ;AACN,WAAKG,MAAL,GAAc,KAAKJ,KAAL,GAAa,CAA3B;AACD;;;WAED,kBAAS;AACP,aAAO,KAAKC,GAAL,GAAW,KAAKD,KAAvB;AACD;;;WAED,iBAAQ;AACN,aAAO,KAAKD,MAAL,CAAYT,KAAZ,CAAkB,KAAKU,KAAvB,EAA8B,KAAKC,GAAnC,CAAP;AACD;;;WAED,gBAAO;AACL;AACAI,MAAAA,OAAO,CAACC,GAAR,CACE,CAAC,KAAKP,MAAL,CAAYQ,UAAZ,CAAuB,KAAKP,KAA5B,EAAmC,KAAKC,GAAxC,CAAD,CADF,EAEE,KAAKF,MAAL,CAAYT,KAAZ,CAAkB,KAAKU,KAAvB,EAA8B,KAAKC,GAAnC,CAFF,EAGE,KAAKZ,MAAL,EAHF,EAIE,KAAKa,UAJP;AAMD;;;WAED,wBAAe;AACb,aAAO,KAAKD,GAAL,GAAW,KAAKG,MAAvB;AACD;;;WAED,cAAKnB,GAAL,EAAU;AACR,WAAKmB,MAAL,IAAenB,GAAf;AACD;;;WAED,oBAAW;AACT,aAAO,KAAKc,MAAL,CAAY,KAAKK,MAAL,EAAZ,CAAP;AACD;;;WAED,qBAAY;AACV,WAAKA,MAAL,IAAe,CAAf;AACA,aAAO,KAAKL,MAAL,CAAYS,YAAZ,CAAyB,KAAKJ,MAAL,GAAc,CAAvC,CAAP;AACD;;;WAED,qBAAY;AACV,aAAO,KAAKK,SAAL,MAAoB,KAAKC,QAAL,MAAmB,EAAvC,CAAP;AACD;;;WAED,qBAAY;AACV,WAAKN,MAAL,IAAe,CAAf;AACA,aAAO,KAAKL,MAAL,CAAYY,YAAZ,CAAyB,KAAKP,MAAL,GAAc,CAAvC,CAAP;AACD;;;WAED,qBAAY;AACV,aAAO,KAAKL,MAAL,CAAYW,QAAZ,CAAqB,KAAKN,MAAL,EAArB,CAAP;AACD;;;WAED,sBAAa;AACX,WAAKA,MAAL,IAAe,CAAf;AACA,aAAO,KAAKL,MAAL,CAAYa,WAAZ,CAAwB,KAAKR,MAAL,GAAc,CAAtC,CAAP;AACD;;;WAED,sBAAa;AACX,WAAKA,MAAL,IAAe,CAAf;AACA,aAAO,KAAKL,MAAL,CAAYc,WAAZ,CAAwB,KAAKT,MAAL,GAAc,CAAtC,CAAP;AACD;;;WAED,6BAAoB;AAClB,UAAMU,KAAK,GAAG,KAAKC,SAAL,EAAd;AACA,UAAMC,KAAK,GAAG,KAAKD,SAAL,EAAd;AACA,UAAME,CAAC,GAAG,IAAIvC,IAAJ,CAASoC,KAAT,EAAgBE,KAAhB,EAAuB,IAAvB,CAAV;AACA,aAAOC,CAAC,CAACC,QAAF,EAAP;AACD;;;WAED,8BAAqB;AACnB,UAAMJ,KAAK,GAAG,KAAKC,SAAL,EAAd;AACA,UAAMC,KAAK,GAAG,KAAKD,SAAL,EAAd;;AACA,UAAI,EAAEC,KAAK,GAAG,UAAV,CAAJ,EAA2B;AACzB,eAAOF,KAAK,GAAG,cAAcE,KAA7B;AACD;;AACD,UAAMC,CAAC,GAAG,IAAIvC,IAAJ,CAASoC,KAAT,EAAgBE,KAAhB,EAAuB,KAAvB,CAAV;AACA,aAAOC,CAAC,CAACC,QAAF,EAAP;AACD;;;WAED,2BAAkB;AAChB,UAAMJ,KAAK,GAAG,KAAKC,SAAL,EAAd;AACA,UAAMC,KAAK,GAAG,KAAKD,SAAL,EAAd;AACA,UAAMI,GAAG,GAAG,IAAIzC,IAAJ,CAASoC,KAAT,EAAgBE,KAAhB,EAAuB,IAAvB,CAAZ;AACA,aAAOG,GAAG,CAAC/B,QAAJ,EAAP;AACD;;;WAED,4BAAmB;AACjB,UAAM0B,KAAK,GAAG,KAAKC,SAAL,EAAd;AACA,UAAMC,KAAK,GAAG,KAAKD,SAAL,EAAd;AACA,UAAMI,GAAG,GAAG,IAAIzC,IAAJ,CAASoC,KAAT,EAAgBE,KAAhB,EAAuB,KAAvB,CAAZ;AACA,aAAOG,GAAG,CAAC/B,QAAJ,EAAP;AACD;;;WAED,qBAAY;AACV,UAAM0B,KAAK,GAAG,KAAKC,SAAL,EAAd;AACA,UAAMC,KAAK,GAAG,KAAKD,SAAL,EAAd;AACA,UAAII,GAAG,GAAG,IAAIzC,IAAJ,CAASoC,KAAT,EAAgBE,KAAhB,EAAuB,IAAvB,CAAV;AACA,UAAMI,SAAS,GAAGD,GAAG,CAACD,QAAJ,EAAlB;AACA,UAAMG,SAAS,GAAGF,GAAG,CAAC/B,QAAJ,EAAlB;AACA+B,MAAAA,GAAG,GAAGC,SAAS,CAAChC,QAAV,OAAyBiC,SAAzB,GAAqCD,SAArC,GAAiDC,SAAvD;AACA,aAAOF,GAAP;AACD;;;WAED,sBAAa;AACX,UAAML,KAAK,GAAG,KAAKC,SAAL,EAAd;AACA,UAAMC,KAAK,GAAG,KAAKD,SAAL,EAAd;AACA,UAAII,GAAG,GAAG,IAAIzC,IAAJ,CAASoC,KAAT,EAAgBE,KAAhB,EAAuB,KAAvB,CAAV;AACA,UAAMI,SAAS,GAAGD,GAAG,CAACD,QAAJ,EAAlB;AACA,UAAMG,SAAS,GAAGF,GAAG,CAAC/B,QAAJ,EAAlB;AACA+B,MAAAA,GAAG,GAAGC,SAAS,CAAChC,QAAV,OAAyBiC,SAAzB,GAAqCD,SAArC,GAAiDC,SAAvD;AACA,aAAOF,GAAP;AACD;;;WAED,iBAAQ;AACN,aAAO,KAAKpB,MAAL,CAAY,KAAKK,MAAjB,MAA6B,IAA7B,IAAqC,KAAKf,MAAL,KAAgB,EAA5D;AACD;;;WAED,0BAAiB;AACf,aAAO,KAAKU,MAAL,CAAYa,WAAZ,CAAwB,KAAKR,MAAL,GAAc,CAAtC,CAAP;AACD;;;WAED,2BAAkB;AAChB,aAAO,KAAKL,MAAL,CAAYa,WAAZ,CAAwB,KAAKR,MAAL,GAAc,CAAtC,CAAP;AACD;;;WAED,+BAAsBkB,gBAAtB,EAAwCC,MAAxC,EAAgD;AAC9C,UAAMC,KAAK,GAAG,KAAKzB,MAAL,CAAY,KAAKK,MAAL,EAAZ,CAAd;;AACA,UAAIoB,KAAK,GAAG,GAAZ,EAAiB;AACf,eAAOA,KAAP;AACD;;AACD,aAAO,KAAKC,wBAAL,CAA8BD,KAA9B,EAAqCF,gBAArC,EAAuDC,MAAvD,CAAP;AACD;;;WAED,qCAA4BD,gBAA5B,EAA8C;AAC5C,aAAO,KAAKI,qBAAL,CAA2BJ,gBAA3B,EAA6C,IAA7C,CAAP;AACD;;;WAED,kCAAyBK,GAAzB,EAA8BL,gBAA9B,EAAgDC,MAAhD,EAAwD;AACtD,UAAIT,KAAJ,EAAWE,KAAX;AACA,UAAIG,GAAJ;;AACA,UAAIQ,GAAG,KAAK,IAAZ,EAAkB;AAChB,eAAO,IAAP;AACD;;AACD,UAAIA,GAAG,KAAK,IAAZ,EAAkB;AAChB,eAAO,KAAKjB,QAAL,MAAmB,KAAKA,QAAL,MAAmB,CAAtC,CAAP;AACD;;AACD,UAAIiB,GAAG,KAAK,IAAZ,EAAkB;AAChB,eAAO,KAAKjB,QAAL,MAAmB,KAAKA,QAAL,MAAmB,CAAtC,KAA4C,KAAKA,QAAL,MAAmB,EAA/D,CAAP;AACD;;AACD,UAAIiB,GAAG,KAAK,IAAZ,EAAkB;AAChB;AACA;AACAb,QAAAA,KAAK,GAAG,KAAKC,SAAL,EAAR;AACAC,QAAAA,KAAK,GAAG,KAAKD,SAAL,EAAR;;AACA,YAAIC,KAAK,KAAK,CAAd,EAAiB;AACf,iBAAOF,KAAP,CADe,CACD;AACf;;AACD,YAAIE,KAAK,GAAG,OAAZ,EAAqB;AACnB;AACA,iBAAOA,KAAK,GAAG,WAAR,GAAsBF,KAA7B;AACD;;AACDK,QAAAA,GAAG,GAAG,IAAIzC,IAAJ,CAASoC,KAAT,EAAgBE,KAAhB,EAAuB,CAACO,MAAxB,CAAN,CAZgB,CAYuB;;AACvC,YAAMH,SAAS,GAAGD,GAAG,CAACD,QAAJ,EAAlB;AACA,YAAMG,SAAS,GAAGF,GAAG,CAAC/B,QAAJ,EAAlB;AACA+B,QAAAA,GAAG,GAAGC,SAAS,CAAChC,QAAV,OAAyBiC,SAAzB,GAAqCD,SAArC,GAAiDC,SAAvD;AACA,eAAOC,gBAAgB,GAAGD,SAAH,GAAeF,GAAtC;AACD,OA7BqD,CA8BtD;;;AACAd,MAAAA,OAAO,CAACuB,KAAR;AACA,YAAM,IAAIC,KAAJ,kCAAoCF,GAApC,EAAN;AACD;;;WAED,qBAAY;AACV,UAAMR,GAAG,GAAG,KAAKpB,MAAL,CAAY+B,WAAZ,CAAwB,KAAK1B,MAA7B,CAAZ;AACA,WAAKA,MAAL,IAAe,CAAf;AACA,aAAOe,GAAP;AACD;;;WAED,sBAAa;AACX,UAAMA,GAAG,GAAG,KAAKpB,MAAL,CAAYgC,YAAZ,CAAyB,KAAK3B,MAA9B,CAAZ;AACA,WAAKA,MAAL,IAAe,CAAf;AACA,aAAOe,GAAP;AACD;;;WAED,oBAAWa,GAAX,EAAgB;AACd,UAAI,OAAOA,GAAP,KAAe,WAAnB,EAAgC;AAC9BA,QAAAA,GAAG,GAAG,KAAK/B,GAAL,GAAW,KAAKG,MAAtB;AACD;;AACD,WAAKA,MAAL,IAAe4B,GAAf;AACA,aAAO,KAAKjC,MAAL,CAAYT,KAAZ,CAAkB,KAAKc,MAAL,GAAc4B,GAAhC,EAAqC,KAAK5B,MAA1C,CAAP;AACD,K,CAED;;;;WACA,sBAAa6B,QAAb,EAAuB;AACrB,UAAI,CAACA,QAAD,IAAaA,QAAQ,KAAK,GAA1B,IAAiCA,QAAQ,KAAK,OAAlD,EAA2D;AACzD,YAAM5C,MAAM,GAAG,KAAKqB,QAAL,EAAf;;AACA,YAAIrB,MAAM,KAAK,IAAf,EAAqB;AACnB,iBAAO,IAAP;AACD;;AACD,YAAI6C,CAAC,GAAG,CAAR;AACA,YAAIC,CAAC,GAAG,CAAR;AACA,YAAIC,CAAC,GAAG,CAAR;AACA,YAAIC,CAAC,GAAG,CAAR;AACA,YAAIC,CAAC,GAAG,CAAR;AACA,YAAIC,CAAC,GAAG,CAAR;AACA,YAAIC,EAAE,GAAG,CAAT;;AACA,YAAInD,MAAM,GAAG,CAAb,EAAgB;AACd6C,UAAAA,CAAC,GAAG,KAAKzB,SAAL,EAAJ;AACA0B,UAAAA,CAAC,GAAG,KAAKzB,QAAL,EAAJ;AACA0B,UAAAA,CAAC,GAAG,KAAK1B,QAAL,EAAJ;AACD;;AACD,YAAIrB,MAAM,GAAG,CAAb,EAAgB;AACdgD,UAAAA,CAAC,GAAG,KAAK3B,QAAL,EAAJ;AACA4B,UAAAA,CAAC,GAAG,KAAK5B,QAAL,EAAJ;AACA6B,UAAAA,CAAC,GAAG,KAAK7B,QAAL,EAAJ;AACD;;AACD,YAAIrB,MAAM,GAAG,EAAb,EAAiB;AACfmD,UAAAA,EAAE,GAAG,KAAKzB,SAAL,KAAmB,IAAxB;AACD,SAxBwD,CAyBzD;AACA;AACA;AACA;AACA;;;AACA,YAAImB,CAAC,GAAGC,CAAJ,GAAQC,CAAR,GAAYC,CAAZ,GAAgBC,CAAhB,GAAoBC,CAApB,GAAwBC,EAAxB,KAA+B,CAAnC,EAAsC;AACpC,iBAAO5D,YAAP;AACD;;AACD,YAAIqD,QAAQ,KAAK,GAAjB,EAAsB;AACpB,iBAAO,IAAIpD,IAAJ,CAASA,IAAI,CAAC4D,GAAL,CAASP,CAAT,EAAYC,CAAC,GAAG,CAAhB,EAAmBC,CAAnB,EAAsBC,CAAtB,EAAyBC,CAAzB,EAA4BC,CAA5B,EAA+BC,EAA/B,CAAT,CAAP;AACD;;AACD,eAAO,IAAI3D,IAAJ,CAASqD,CAAT,EAAYC,CAAC,GAAG,CAAhB,EAAmBC,CAAnB,EAAsBC,CAAtB,EAAyBC,CAAzB,EAA4BC,CAA5B,EAA+BC,EAA/B,CAAP;AACD;;AACD,UAAIE,GAAG,GAAG,KAAKC,kBAAL,CAAwB,CAAxB,EAA2B,GAA3B,CAAV;;AACA,UAAID,GAAG,CAACrD,MAAJ,KAAe,EAAnB,EAAuB;AACrBqD,QAAAA,GAAG,IAAI,WAAP;AACD;;AACD,aAAO,IAAI7D,IAAJ,CAAS6D,GAAG,GAAGT,QAAf,CAAP;AACD;;;WAED,4BAAmBW,QAAnB,EAA6BC,OAA7B,EAAsC;AACpC,UAAMxD,MAAM,GAAG,KAAKqB,QAAL,EAAf;AACA,UAAIwB,CAAC,GAAG,CAAR;AACA,UAAIC,CAAC,GAAG,CAAR;AACA,UAAIC,CAAC,GAAG,CAAR;AACA,UAAIC,CAAC,GAAG,CAAR;AACA,UAAIC,CAAC,GAAG,CAAR;AACA,UAAIC,CAAC,GAAG,CAAR;AACA,UAAIC,EAAE,GAAG,CAAT;AACA,UAAIE,GAAJ;;AACA,UAAIrD,MAAM,GAAG,CAAb,EAAgB;AACd6C,QAAAA,CAAC,GAAG,KAAKzB,SAAL,EAAJ;AACA0B,QAAAA,CAAC,GAAG,KAAKzB,QAAL,EAAJ;AACA0B,QAAAA,CAAC,GAAG,KAAK1B,QAAL,EAAJ;AACAgC,QAAAA,GAAG,GAAG,CAAC1D,OAAO,CAAC,CAAD,EAAIkD,CAAJ,CAAR,EAAgBlD,OAAO,CAAC,CAAD,EAAImD,CAAJ,CAAvB,EAA+BnD,OAAO,CAAC,CAAD,EAAIoD,CAAJ,CAAtC,EAA8CU,IAA9C,CAAmD,GAAnD,CAAN;AACD;;AACD,UAAIzD,MAAM,GAAG,CAAb,EAAgB;AACdgD,QAAAA,CAAC,GAAG,KAAK3B,QAAL,EAAJ;AACA4B,QAAAA,CAAC,GAAG,KAAK5B,QAAL,EAAJ;AACA6B,QAAAA,CAAC,GAAG,KAAK7B,QAAL,EAAJ;AACAgC,QAAAA,GAAG,cAAOG,OAAO,IAAI,GAAlB,SAAwB,CACzB7D,OAAO,CAAC,CAAD,EAAIqD,CAAJ,CADkB,EAEzBrD,OAAO,CAAC,CAAD,EAAIsD,CAAJ,CAFkB,EAGzBtD,OAAO,CAAC,CAAD,EAAIuD,CAAJ,CAHkB,EAIzBO,IAJyB,CAIpB,GAJoB,CAAxB,CAAH;AAKD;;AACD,UAAIzD,MAAM,GAAG,EAAb,EAAiB;AACfmD,QAAAA,EAAE,GAAG,KAAKzB,SAAL,EAAL;AACA2B,QAAAA,GAAG,IAAI,GAAP;;AACA,YAAIE,QAAJ,EAAc;AACZJ,UAAAA,EAAE,GAAGxD,OAAO,CAAC,CAAD,EAAIwD,EAAJ,CAAZ;;AACA,cAAIA,EAAE,CAACnD,MAAH,GAAYuD,QAAhB,EAA0B;AACxBJ,YAAAA,EAAE,GAAGA,EAAE,CAACO,SAAH,CAAa,CAAb,EAAgBH,QAAhB,CAAL,CADwB,CACQ;AACjC;AACF;;AACDF,QAAAA,GAAG,IAAIF,EAAP;AACD;;AACD,aAAOE,GAAP;AACD,K,CAED;;;;WACA,wBAAeM,YAAf,EAA6B;AAC3B,UAAM3D,MAAM,GAAG,KAAKqB,QAAL,EAAf;;AACA,UAAIrB,MAAM,KAAK,CAAf,EAAkB;AAChB,eAAO,UAAP;AACD;;AACD,UAAM4D,IAAI,GAAG,KAAKvC,QAAL,KAAkB,CAAC,CAAnB,GAAuB,CAApC,CAL2B,CAKY;;AACvC,UAAI0B,CAAC,GAAG,CAAR;AACA,UAAIC,CAAC,GAAG,CAAR;AACA,UAAIC,CAAC,GAAG,CAAR;AACA,UAAIC,CAAC,GAAG,CAAR;AACA,UAAIC,EAAE,GAAG,CAAT;;AACA,UAAInD,MAAM,GAAG,CAAb,EAAgB;AACd+C,QAAAA,CAAC,GAAG,KAAKrB,SAAL,EAAJ;AACAsB,QAAAA,CAAC,GAAG,KAAK3B,QAAL,EAAJ;AACA4B,QAAAA,CAAC,GAAG,KAAK5B,QAAL,EAAJ;AACA6B,QAAAA,CAAC,GAAG,KAAK7B,QAAL,EAAJ;AACD;;AACD,UAAIrB,MAAM,GAAG,EAAb,EAAiB;AACfmD,QAAAA,EAAE,GAAG,KAAKzB,SAAL,EAAL;AACD;;AACD,UAAIiC,YAAJ,EAAkB;AAChBX,QAAAA,CAAC,IAAID,CAAC,GAAG,EAAT;AACAE,QAAAA,CAAC,IAAID,CAAC,GAAG,EAAT;AACAE,QAAAA,CAAC,IAAID,CAAC,GAAG,EAAT;AACAE,QAAAA,EAAE,IAAID,CAAC,GAAG,IAAV;AACAC,QAAAA,EAAE,IAAIS,IAAN;AACA,eAAOT,EAAP;AACD;;AACD,aACE,CAACS,IAAI,KAAK,CAAC,CAAV,GAAc,GAAd,GAAoB,EAArB,IACA,CAACb,CAAC,GAAGA,CAAC,GAAG,EAAJ,GAASC,CAAZ,GAAgBA,CAAlB,EAAqBrD,OAAO,CAAC,CAAD,EAAIsD,CAAJ,CAA5B,EAAoCtD,OAAO,CAAC,CAAD,EAAIuD,CAAJ,CAA3C,EAAmDO,IAAnD,CAAwD,GAAxD,CADA,IAECN,EAAE,cAAOA,EAAP,IAAc,EAFjB,CADF;AAKD;;;WAED,+BAAsBU,QAAtB,EAAgC;AAC9B,UAAMlB,GAAG,GAAG,KAAKN,qBAAL,EAAZ,CAD8B,CAE9B;;AACA,UAAIM,GAAG,KAAK,IAAZ,EAAkB;AAChB,eAAO,IAAP;AACD;;AACD,WAAK5B,MAAL,IAAe4B,GAAf,CAN8B,CAO9B;AACA;;AACA,aAAOrD,YAAY,CAACwE,MAAb,CACL,KAAKpD,MAAL,CAAYT,KAAZ,CAAkB,KAAKc,MAAL,GAAc4B,GAAhC,EAAqC,KAAK5B,MAA1C,CADK,EAEL8C,QAFK,CAAP;AAID;;;WAED,iCAAwB;AACtB,UAAMlB,GAAG,GAAG,KAAKN,qBAAL,EAAZ;;AACA,UAAIM,GAAG,KAAK,IAAZ,EAAkB;AAChB,eAAO,IAAP;AACD;;AACD,aAAO,KAAKoB,UAAL,CAAgBpB,GAAhB,CAAP;AACD;;;WAED,kCAAyBkB,QAAzB,EAAmC;AACjC,UAAMlD,KAAK,GAAG,KAAKI,MAAnB;AACA,UAAIH,GAAG,GAAG,KAAKG,MAAf;;AACA,aAAO,KAAKL,MAAL,CAAYE,GAAZ,CAAP,EAAyB;AACvBA,QAAAA,GAAG,GAAGA,GAAG,GAAG,CAAZ,CADuB,CACR;AAChB;;AACD,WAAKG,MAAL,GAAcH,GAAG,GAAG,CAApB;AACA,aAAOtB,YAAY,CAACwE,MAAb,CAAoB,KAAKpD,MAAL,CAAYT,KAAZ,CAAkBU,KAAlB,EAAyBC,GAAzB,CAApB,EAAmDiD,QAAnD,CAAP;AACD,K,CAED;;;;WACA,oBAAWlB,GAAX,EAAgBkB,QAAhB,EAA0B;AACxB,UAAK,OAAOlB,GAAP,KAAe,QAAhB,IAA8B,OAAOkB,QAAP,KAAoB,WAAtD,EAAoE;AAClEA,QAAAA,QAAQ,GAAGlB,GAAX;AACAA,QAAAA,GAAG,GAAGqB,SAAN;AACD;;AACD,UAAI,OAAOrB,GAAP,KAAe,WAAnB,EAAgC;AAC9BA,QAAAA,GAAG,GAAG,KAAK/B,GAAL,GAAW,KAAKG,MAAtB;AACD;;AACD,WAAKA,MAAL,IAAe4B,GAAf;AACA,aAAOrD,YAAY,CAACwE,MAAb,CACL,KAAKpD,MAAL,CAAYT,KAAZ,CAAkB,KAAKc,MAAL,GAAc4B,GAAhC,EAAqC,KAAK5B,MAA1C,CADK,EAEL8C,QAFK,CAAP;AAID;;;;;;;;;;;;;MAED,UAASlB,GAAT,EAAcsB,iBAAd,EAAiC;AAC/B,UAAItB,GAAG,KAAK,IAAZ,EAAkB;AAChB,eAAO,IAAP;AACD;;AACD,UAAIA,GAAG,IAAI,EAAP,IAAa,CAACsB,iBAAlB,EAAqC;AACnC,YAAMnE,CAAC,GAAG,KAAKY,MAAL,CAAYX,QAAZ,CAAqB,OAArB,EAA8B,KAAKgB,MAAnC,EAA2C,KAAKA,MAAL,GAAc4B,GAAzD,CAAV;AACA,aAAK5B,MAAL,IAAe4B,GAAf;AACA,eAAOuB,MAAM,CAACpE,CAAD,CAAb;AACD;;AACD,UAAIqE,MAAM,GAAG,CAAb;AACA,UAAMxD,KAAK,GAAG,KAAKI,MAAnB;AACA,UAAMH,GAAG,GAAG,KAAKG,MAAL,GAAc4B,GAA1B;AACA,UAAIiB,IAAI,GAAG,CAAX;;AACA,UAAIjB,GAAG,KAAK,CAAZ,EAAe;AACb,eAAO,CAAP,CADa,CACH;AACX;;AACD,UAAI,KAAKjC,MAAL,CAAY,KAAKK,MAAjB,MAA6Bb,KAAjC,EAAwC;AACtC,aAAKa,MAAL;AACA6C,QAAAA,IAAI,GAAG,CAAC,CAAR;AACD,OAnB8B,CAoB/B;;;AACA,UAAIP,GAAJ;AACA,UAAMe,SAAS,GAAGxD,GAAG,GAAG,KAAKG,MAA7B;;AACA,UAAIkD,iBAAJ,EAAuB;AACrB,YAAIG,SAAS,IAAI,EAAjB,EAAqB;AACnBf,UAAAA,GAAG,GAAG,KAAKgB,UAAL,CAAgBzD,GAAG,GAAG,KAAKG,MAA3B,EAAmC,QAAnC,CAAN;AACAoD,UAAAA,MAAM,GAAGG,QAAQ,CAACjB,GAAD,EAAM,EAAN,CAAjB;;AACA,cAAIc,MAAM,CAACpE,QAAP,OAAsBsD,GAA1B,EAA+B;AAC7B,mBAAOO,IAAI,GAAGO,MAAd;AACD;;AACD,iBAAOP,IAAI,KAAK,CAAC,CAAV,cAAkBP,GAAlB,IAA0BA,GAAjC;AACD;;AACD,YAAIe,SAAS,GAAG,EAAhB,EAAoB;AAClBf,UAAAA,GAAG,GAAG,KAAKgB,UAAL,CAAgBzD,GAAG,GAAG,KAAKG,MAA3B,CAAN;AACA,iBAAO6C,IAAI,KAAK,CAAC,CAAV,cAAkBP,GAAlB,IAA0BA,GAAjC;AACD;AACF;;AACD,UAAI,KAAK3C,MAAL,CAAY,KAAKK,MAAjB,MAA6BX,IAAjC,EAAuC;AACrC,aAAKW,MAAL,GADqC,CACtB;AAChB;;AACD,aAAO,KAAKA,MAAL,GAAcH,GAArB,EAA0B;AACxBuD,QAAAA,MAAM,IAAI,EAAV;AACAA,QAAAA,MAAM,IAAI,KAAKzD,MAAL,CAAY,KAAKK,MAAjB,IAA2B,EAArC;AACA,aAAKA,MAAL;AACD;;AACD,UAAMnB,GAAG,GAAGuE,MAAM,GAAGP,IAArB;;AACA,UAAI,CAACK,iBAAL,EAAwB;AACtB,eAAOrE,GAAP;AACD;;AACDyD,MAAAA,GAAG,GAAG,KAAK3C,MAAL,CAAYX,QAAZ,CAAqB,OAArB,EAA8BY,KAA9B,EAAqCC,GAArC,CAAN;;AACA,UAAIhB,GAAG,CAACG,QAAJ,OAAmBsD,GAAvB,EAA4B;AAC1B,eAAOzD,GAAP;AACD;;AACD,aAAOyD,GAAP;AACD,K,CAED;AACA;AACA;AACA;;;;WACA,4BAAmBV,GAAnB,EAAwB;AACtB,UAAIA,GAAG,KAAK,IAAZ,EAAkB;AAChB,eAAO,IAAP;AACD;;AACD,UAAIwB,MAAM,GAAG,CAAb;AACA,UAAMvD,GAAG,GAAG,KAAKG,MAAL,GAAc4B,GAA1B;AACA,UAAIiB,IAAI,GAAG,CAAX;;AACA,UAAIjB,GAAG,KAAK,CAAZ,EAAe;AACb,eAAO,CAAP,CADa,CACH;AACX;;AACD,UAAI,KAAKjC,MAAL,CAAY,KAAKK,MAAjB,MAA6Bb,KAAjC,EAAwC;AACtC,aAAKa,MAAL;AACA6C,QAAAA,IAAI,GAAG,CAAC,CAAR;AACD;;AACD,UAAI,KAAKlD,MAAL,CAAY,KAAKK,MAAjB,MAA6BX,IAAjC,EAAuC;AACrC,aAAKW,MAAL,GADqC,CACtB;AAChB;;AACD,aAAO,KAAKA,MAAL,GAAcH,GAArB,EAA0B;AACxBuD,QAAAA,MAAM,IAAI,EAAV;AACAA,QAAAA,MAAM,IAAI,KAAKzD,MAAL,CAAY,KAAKK,MAAjB,IAA2B,EAArC;AACA,aAAKA,MAAL;AACD;;AACD,aAAOoD,MAAM,GAAGP,IAAhB;AACD,K,CAED;;;;WACA,8BAAqB;AACnB,UAAMlD,MAAM,GAAG,KAAK6D,qBAAL,EAAf;AACA,UAAIxD,MAAM,GAAG,CAAb;;AACA,UAAIL,MAAM,KAAK,IAAX,IAAmB,CAACA,MAAM,CAACV,MAA/B,EAAuC;AACrC,eAAO,IAAP;AACD;;AACD,eAASwE,aAAT,GAAyB;AACvB,YAAIC,CAAJ,EAAO5B,CAAP,EAAU6B,CAAV,EAAaC,CAAb,EAAgBC,SAAhB,EAA2BC,IAA3B;AACA,YAAIV,MAAM,GAAG,IAAb;AACA,YAAMW,SAAS,GAAGpE,MAAM,CAACqE,SAAP,CAAiBhE,MAAjB,CAAlB;AACAA,QAAAA,MAAM,IAAI,CAAV;AACA,YAAMiE,OAAO,GAAGF,SAAS,GACrBpE,MAAM,CAACY,YAAP,CAAoBP,MAApB,CADqB,GAErBL,MAAM,CAACuE,YAAP,CAAoBlE,MAApB,CAFJ;AAGAA,QAAAA,MAAM,IAAI,CAAV;;AACA,gBAAQiE,OAAR;AACE,eAAK,CAAL;AAAQ;AACNP,YAAAA,CAAC,GAAGK,SAAS,GACTpE,MAAM,CAACgC,YAAP,CAAoB3B,MAApB,CADS,GAETL,MAAM,CAACwE,YAAP,CAAoBnE,MAApB,CAFJ;AAGAA,YAAAA,MAAM,IAAI,CAAV;AACA8B,YAAAA,CAAC,GAAGiC,SAAS,GACTpE,MAAM,CAACgC,YAAP,CAAoB3B,MAApB,CADS,GAETL,MAAM,CAACwE,YAAP,CAAoBnE,MAApB,CAFJ;AAGAA,YAAAA,MAAM,IAAI,CAAV;AACAoD,YAAAA,MAAM,GAAG;AAAEM,cAAAA,CAAC,EAAEA,CAAL;AAAQ5B,cAAAA,CAAC,EAAEA;AAAX,aAAT;AACA;;AACF,eAAK,CAAL;AAAQ;AACN+B,YAAAA,SAAS,GAAGE,SAAS,GACjBpE,MAAM,CAACY,YAAP,CAAoBP,MAApB,CADiB,GAEjBL,MAAM,CAACuE,YAAP,CAAoBlE,MAApB,CAFJ;AAGAA,YAAAA,MAAM,IAAI,CAAV;AACAoD,YAAAA,MAAM,GAAG,EAAT;;AACA,iBAAKO,CAAC,GAAGE,SAAT,EAAoBF,CAAC,GAAG,CAAxB,EAA2BA,CAAC,EAA5B,EAAgC;AAC9BD,cAAAA,CAAC,GAAGK,SAAS,GACTpE,MAAM,CAACgC,YAAP,CAAoB3B,MAApB,CADS,GAETL,MAAM,CAACwE,YAAP,CAAoBnE,MAApB,CAFJ;AAGAA,cAAAA,MAAM,IAAI,CAAV;AACA8B,cAAAA,CAAC,GAAGiC,SAAS,GACTpE,MAAM,CAACgC,YAAP,CAAoB3B,MAApB,CADS,GAETL,MAAM,CAACwE,YAAP,CAAoBnE,MAApB,CAFJ;AAGAA,cAAAA,MAAM,IAAI,CAAV;AACAoD,cAAAA,MAAM,CAACgB,IAAP,CAAY;AAAEV,gBAAAA,CAAC,EAAEA,CAAL;AAAQ5B,gBAAAA,CAAC,EAAEA;AAAX,eAAZ;AACD;;AACD;;AACF,eAAK,CAAL;AAAQ;AACN;AACA,gBAAMuC,QAAQ,GAAGN,SAAS,GACtBpE,MAAM,CAACY,YAAP,CAAoBP,MAApB,CADsB,GAEtBL,MAAM,CAACuE,YAAP,CAAoBlE,MAApB,CAFJ;AAGAA,YAAAA,MAAM,IAAI,CAAV;AACAoD,YAAAA,MAAM,GAAG,EAAT;;AACA,iBAAKO,CAAC,GAAGU,QAAT,EAAmBV,CAAC,GAAG,CAAvB,EAA0BA,CAAC,EAA3B,EAA+B;AAC7BE,cAAAA,SAAS,GAAGE,SAAS,GACjBpE,MAAM,CAACY,YAAP,CAAoBP,MAApB,CADiB,GAEjBL,MAAM,CAACuE,YAAP,CAAoBlE,MAApB,CAFJ;AAGAA,cAAAA,MAAM,IAAI,CAAV;AACA8D,cAAAA,IAAI,GAAG,EAAP;;AACA,mBAAKF,CAAC,GAAGC,SAAT,EAAoBD,CAAC,GAAG,CAAxB,EAA2BA,CAAC,EAA5B,EAAgC;AAC9BF,gBAAAA,CAAC,GAAGK,SAAS,GACTpE,MAAM,CAACgC,YAAP,CAAoB3B,MAApB,CADS,GAETL,MAAM,CAACwE,YAAP,CAAoBnE,MAApB,CAFJ;AAGAA,gBAAAA,MAAM,IAAI,CAAV;AACA8B,gBAAAA,CAAC,GAAGiC,SAAS,GACTpE,MAAM,CAACgC,YAAP,CAAoB3B,MAApB,CADS,GAETL,MAAM,CAACwE,YAAP,CAAoBnE,MAApB,CAFJ;AAGAA,gBAAAA,MAAM,IAAI,CAAV;AACA8D,gBAAAA,IAAI,CAACM,IAAL,CAAU;AAAEV,kBAAAA,CAAC,EAAEA,CAAL;AAAQ5B,kBAAAA,CAAC,EAAEA;AAAX,iBAAV;AACD;;AACDsB,cAAAA,MAAM,CAACgB,IAAP,CAAYN,IAAZ;AACD;;AACD;;AACF,eAAK,CAAL,CAzDF,CAyDU;;AACR,eAAK,CAAL,CA1DF,CA0DU;;AACR,eAAK,CAAL,CA3DF,CA2DU;;AACR,eAAK,CAAL;AAAQ;AACN;AACA,gBAAMjF,GAAG,GAAGkF,SAAS,GACjBpE,MAAM,CAACY,YAAP,CAAoBP,MAApB,CADiB,GAEjBL,MAAM,CAACuE,YAAP,CAAoBlE,MAApB,CAFJ;AAGAA,YAAAA,MAAM,IAAI,CAAV;AACAoD,YAAAA,MAAM,GAAG,EAAT;;AACA,iBAAKO,CAAC,GAAG9E,GAAT,EAAc8E,CAAC,GAAG,CAAlB,EAAqBA,CAAC,EAAtB,EAA0B;AACxBP,cAAAA,MAAM,CAACgB,IAAP,CAAYX,aAAa,EAAzB;AACD;;AACD;AAtEJ;;AAwEA,eAAOL,MAAP;AACD;;AACD,aAAOK,aAAa,EAApB;AACD;;;WAED,mBAAU5B,QAAV,EAAoB;AAClB,UAAMyC,MAAM,GAAG,KAAKhD,qBAAL,EAAf;;AACA,UAAIgD,MAAM,KAAK,IAAf,EAAqB;AACnB,eAAO,IAAP;AACD;;AACD,UAAIA,MAAM,KAAK,EAAf,EAAmB;AACjB;AACA;AACA,eAAO,IAAI7F,IAAJ,CAASC,GAAT,CAAP;AACD;;AACD,UAAMoD,CAAC,GAAG,KAAKyB,QAAL,CAAc,CAAd,CAAV;AACA,WAAKvD,MAAL,GAXkB,CAWH;;AACf,UAAM+B,CAAC,GAAG,KAAKwB,QAAL,CAAc,CAAd,CAAV;AACA,WAAKvD,MAAL,GAbkB,CAaH;;AACf,UAAMgC,CAAC,GAAG,KAAKuB,QAAL,CAAc,CAAd,CAAV;;AACA,UAAI,CAAC1B,QAAD,IAAaA,QAAQ,KAAK,OAA9B,EAAuC;AACrC,eAAO,IAAIpD,IAAJ,CAASqD,CAAT,EAAYC,CAAC,GAAG,CAAhB,EAAmBC,CAAnB,CAAP;AACD;;AACD,UAAIH,QAAQ,KAAK,GAAjB,EAAsB;AACpB,eAAO,IAAIpD,IAAJ,CAASA,IAAI,CAAC4D,GAAL,CAASP,CAAT,EAAYC,CAAC,GAAG,CAAhB,EAAmBC,CAAnB,CAAT,CAAP;AACD;;AACD,aAAO,IAAIvD,IAAJ,WACFG,OAAO,CAAC,CAAD,EAAIkD,CAAJ,CADL,cACelD,OAAO,CAAC,CAAD,EAAImD,CAAJ,CADtB,cACgCnD,OAAO,CAAC,CAAD,EAAIoD,CAAJ,CADvC,sBACyDH,QADzD,EAAP;AAGD;;;WAED,uBAAcA,QAAd,EAAwB;AACtB,UAAMS,GAAG,GAAG,KAAKiC,qBAAL,CAA2B,QAA3B,CAAZ;;AACA,UAAIjC,GAAG,KAAK,IAAZ,EAAkB;AAChB,eAAO,IAAP;AACD;;AACD,UAAI,CAACT,QAAD,IAAaA,QAAQ,KAAK,OAA9B,EAAuC;AACrC,eAAO,IAAIpD,IAAJ,CAAS6D,GAAT,CAAP;AACD;;AACD,aAAO,IAAI7D,IAAJ,WAAY6D,GAAZ,SAAkBT,QAAlB,EAAP;AACD;;;WAED,oBAAWD,GAAX,EAAgB;AACd,UAAIA,GAAG,KAAK,IAAZ,EAAkB;AAChB,eAAO,IAAP;AACD;;AACD,UAAIwB,MAAM,GAAG,CAAb;AACA,UAAMvD,GAAG,GAAG,KAAKG,MAAL,GAAc4B,GAA1B;AACA,UAAI4C,MAAM,GAAG,CAAb;AACA,UAAIC,OAAO,GAAG,KAAd;AACA,UAAIC,QAAQ,GAAG,CAAf;;AACA,UAAI9C,GAAG,KAAK,CAAZ,EAAe;AACb,eAAO,CAAP,CADa,CACH;AACX;;AACD,UAAI,KAAKjC,MAAL,CAAY,KAAKK,MAAjB,MAA6Bb,KAAjC,EAAwC;AACtC,aAAKa,MAAL;AACAwE,QAAAA,MAAM,GAAG,CAAC,CAAV;AACD;;AACD,UAAI,KAAK7E,MAAL,CAAY,KAAKK,MAAjB,MAA6BX,IAAjC,EAAuC;AACrC,aAAKW,MAAL,GADqC,CACtB;AAChB;;AACD,aAAO,KAAKA,MAAL,GAAcH,GAArB,EAA0B;AACxB6E,QAAAA,QAAQ,GAAG,KAAK/E,MAAL,CAAY,KAAKK,MAAjB,CAAX;;AACA,YAAI0E,QAAQ,KAAKpF,GAAjB,EAAsB;AACpBmF,UAAAA,OAAO,GAAG,IAAV;AACA,eAAKzE,MAAL;AACD,SAHD,MAGO,IAAI0E,QAAQ,KAAKnF,QAAb,IAAyBmF,QAAQ,KAAKlF,eAA1C,EAA2D;AAChE,eAAKQ,MAAL;AACA,cAAM2E,aAAa,GAAG,KAAKpB,QAAL,CAAc1D,GAAG,GAAG,KAAKG,MAAzB,CAAtB;AACA,iBAAQoD,MAAM,GAAGoB,MAAV,GAAoBI,IAAI,CAACC,GAAL,CAAS,EAAT,EAAaF,aAAb,CAA3B;AACD,SAJM,MAIA;AACLvB,UAAAA,MAAM,IAAI,EAAV;AACAA,UAAAA,MAAM,IAAI,KAAKzD,MAAL,CAAY,KAAKK,MAAjB,IAA2B,EAArC;AACA,eAAKA,MAAL;;AACA,cAAIyE,OAAJ,EAAa;AACXD,YAAAA,MAAM,GAAGA,MAAM,GAAG,EAAlB;AACD;AACF;AACF;;AACD,aAAOpB,MAAM,GAAGoB,MAAhB;AACD;;;WAED,yCAAgC;AAC9B,aAAO,KAAKM,kBAAL,CAAwB,KAAKxD,qBAAL,EAAxB,CAAP;AACD;;;WAED,6BAAoB4B,iBAApB,EAAuC;AACrC,aAAO,KAAKK,QAAL,CAAc,KAAKjC,qBAAL,EAAd,EAA4C4B,iBAA5C,CAAP;AACD;;;WAED,qCAA4B;AAC1B,aAAO,KAAKqB,qBAAL,CAA2B,QAA3B,CAAP;AACD;;;WAED,iCAAwB;AACtB,aAAO,KAAKQ,UAAL,CAAgB,KAAKzD,qBAAL,EAAhB,CAAP;AACD;;;WAED,oBAAW;AACT,aAAO,KAAK3B,MAAL,CAAY,KAAKK,MAAjB,CAAP;AACD,K,CAED;AACA;;;;WACA,iBAAQ;AACN,aAAO,KAAKgF,QAAL,OAAoB,IAA3B;AACD;;;WAED,mBAAU;AACR,aAAO,KAAKA,QAAL,OAAoB,IAA3B;AACD;;;WAED,iBAAQlC,QAAR,EAAkB;AAChB,WAAKmC,KAAL;AACA,WAAK3E,QAAL,GAFgB,CAEC;;AACjB,UAAM4E,SAAS,GAAG,KAAK7E,SAAL,EAAlB;AACA,UAAI8E,QAAQ,GAAG,EAAf;;AACA,UAAI,KAAKxF,MAAL,CAAY,KAAKK,MAAjB,MAA6B,IAAjC,EAAuC;AACrC,aAAKoF,IAAL,CAAU,CAAV;AACAD,QAAAA,QAAQ,GAAG,KAAKnC,UAAL,CAAgB,CAAhB,EAAmBhE,QAAnB,EAAX;AACD;;AACD,UAAMqG,OAAO,GAAG,KAAK/B,UAAL,CAAgBL,SAAhB,EAA2BH,QAA3B,CAAhB;AACA,UAAMwC,GAAG,GAAG,IAAI7D,KAAJ,CAAU4D,OAAV,CAAZ;AACAC,MAAAA,GAAG,CAACC,IAAJ,GAAWrH,eAAe,CAACgH,SAAD,CAA1B;AACAI,MAAAA,GAAG,CAACE,KAAJ,GAAYN,SAAZ;AACAI,MAAAA,GAAG,CAACH,QAAJ,GAAeA,QAAf;AACAG,MAAAA,GAAG,CAACG,UAAJ,GAAiBJ,OAAjB;AACA,aAAOC,GAAP;AACD;;;WAED,oBAAWI,CAAX,EAAc;AACZ,WAAK/F,MAAL,CAAYgG,aAAZ,CAA0BD,CAA1B,EAA6B,KAAK1F,MAAlC;AACA,WAAKA,MAAL,IAAe,CAAf;AACD;;;WAED,oBAAW0F,CAAX,EAAc;AACZ,WAAKE,SAAL,CAAeF,CAAC,GAAG,IAAnB;AACA,WAAKG,UAAL,CAAgBH,CAAC,IAAI,CAArB;AACD;;;WAED,oBAAWA,CAAX,EAAc;AACZ,WAAK/F,MAAL,CAAYmG,aAAZ,CAA0BJ,CAA1B,EAA6B,KAAK1F,MAAlC;AACA,WAAKA,MAAL,IAAe,CAAf;AACD;;;WAED,mBAAU0F,CAAV,EAAa;AACX,WAAK/F,MAAL,CAAYoG,UAAZ,CAAuBL,CAAvB,EAA0B,KAAK1F,MAA/B;AACA,WAAKA,MAAL;AACD;;;WAED,qBAAY0F,CAAZ,EAAe;AACb,WAAK/F,MAAL,CAAYqG,aAAZ,CAA0BN,CAA1B,EAA6B,KAAK1F,MAAlC;AACA,WAAKA,MAAL,IAAe,CAAf;AACD;;;WAED,qBAAYiG,CAAZ,EAAe;AACbA,MAAAA,CAAC,CAACC,IAAF,CAAO,KAAKvG,MAAZ,EAAoB,KAAKK,MAAzB;AACA,WAAKA,MAAL,IAAeiG,CAAC,CAAChH,MAAjB;AACD;;;WAED,qBAAY;AACV,WAAKU,MAAL,CAAY,KAAKK,MAAjB,IAA2B,IAA3B;AACA,WAAKA,MAAL;AACD,K,CAED;;;;WACA,mCAA0BjB,CAA1B,EAA6B+D,QAA7B,EAAuC;AACrC,UAAMqD,GAAG,GAAG5H,YAAY,CAAC6H,MAAb,CAAoBrH,CAApB,EAAuB+D,QAAvB,CAAZ;AACA,WAAKnD,MAAL,CAAYV,MAAZ,IAAsBkH,GAAG,CAACD,IAAJ,CAAS,KAAKvG,MAAd,EAAsB,KAAKK,MAA3B,CAAtB;AACA,WAAKA,MAAL,IAAemG,GAAG,CAAClH,MAAnB;AACA,WAAK2G,SAAL,CAAe,CAAf;AACD;;;WAED,qBAAY7G,CAAZ,EAAe+D,QAAf,EAAyB;AACvB,UAAI/D,CAAC,KAAK,IAAV,EAAgB;AACd,aAAK6G,SAAL,CAAe,IAAf;AACA;AACD;;AACD,UAAI7G,CAAC,CAACE,MAAF,KAAa,CAAjB,EAAoB;AAClB;AACD,OAPsB,CAQvB;AACA;AACA;;;AACA,UAAMkH,GAAG,GAAG5H,YAAY,CAAC6H,MAAb,CAAoBrH,CAApB,EAAuB+D,QAAvB,CAAZ;AACA,WAAKnD,MAAL,CAAYV,MAAZ,IAAsBkH,GAAG,CAACD,IAAJ,CAAS,KAAKvG,MAAd,EAAsB,KAAKK,MAA3B,CAAtB;AACA,WAAKA,MAAL,IAAemG,GAAG,CAAClH,MAAnB;AACD;;;WAED,gCAAuBF,CAAvB,EAA0B+D,QAA1B,EAAoC;AAClC,UAAMqD,GAAG,GAAG5H,YAAY,CAAC6H,MAAb,CAAoBrH,CAApB,EAAuB+D,QAAvB,CAAZ;AACA,WAAKuD,sBAAL,CAA4BF,GAAG,CAAClH,MAAhC;AACA,WAAKU,MAAL,CAAYV,MAAZ,IAAsBkH,GAAG,CAACD,IAAJ,CAAS,KAAKvG,MAAd,EAAsB,KAAKK,MAA3B,CAAtB;AACA,WAAKA,MAAL,IAAemG,GAAG,CAAClH,MAAnB;AACD;;;WAED,gCAAuBgH,CAAvB,EAA0B;AACxB,WAAKI,sBAAL,CAA4BJ,CAAC,CAAChH,MAA9B;AACAgH,MAAAA,CAAC,CAACC,IAAF,CAAO,KAAKvG,MAAZ,EAAoB,KAAKK,MAAzB;AACA,WAAKA,MAAL,IAAeiG,CAAC,CAAChH,MAAjB;AACD;;;WAED,gCAAuByG,CAAvB,EAA0B;AACxB,UAAIA,CAAC,GAAG,IAAR,EAAc;AACZ,eAAO,KAAKE,SAAL,CAAeF,CAAf,CAAP;AACD;;AACD,UAAIA,CAAC,GAAG,MAAR,EAAgB;AACd,aAAKE,SAAL,CAAe,IAAf;AACA,eAAO,KAAKC,UAAL,CAAgBH,CAAhB,CAAP;AACD;;AACD,UAAIA,CAAC,GAAG,QAAR,EAAkB;AAChB,aAAKE,SAAL,CAAe,IAAf;AACA,eAAO,KAAKU,UAAL,CAAgBZ,CAAhB,CAAP;AACD;;AACD,UAAIA,CAAC,KAAK,IAAV,EAAgB;AACd,eAAO,KAAKE,SAAL,CAAe,IAAf,CAAP;AACD,OAduB,CAexB;;;AACA,WAAKA,SAAL,CAAe,IAAf;AACA,WAAKjG,MAAL,CAAYgG,aAAZ,CAA0BD,CAA1B,EAA6B,KAAK1F,MAAlC;AACA,WAAKA,MAAL,IAAe,CAAf;AACA,WAAKL,MAAL,CAAYgG,aAAZ,CAA0BD,CAAC,IAAI,EAA/B,EAAmC,KAAK1F,MAAxC;AACA,WAAKA,MAAL,IAAe,CAAf;AACA,aAAO,KAAKA,MAAZ;AACD;;;WAED,mBAAUgC,CAAV,EAAaH,QAAb,EAAuB;AACrB,WAAKlC,MAAL,CAAYoG,UAAZ,CAAuB,EAAvB,EAA2B,KAAK/F,MAAhC;;AACA,UAAI,CAAC6B,QAAD,IAAaA,QAAQ,KAAK,OAA9B,EAAuC;AACrC,aAAKlC,MAAL,CAAYmG,aAAZ,CAA0B9D,CAAC,CAACuE,WAAF,EAA1B,EAA2C,KAAKvG,MAAL,GAAc,CAAzD;AACA,aAAKL,MAAL,CAAYoG,UAAZ,CAAuB/D,CAAC,CAACwE,QAAF,KAAe,CAAtC,EAAyC,KAAKxG,MAAL,GAAc,CAAvD;AACA,aAAKL,MAAL,CAAYoG,UAAZ,CAAuB/D,CAAC,CAACyE,OAAF,EAAvB,EAAoC,KAAKzG,MAAL,GAAc,CAAlD;AACA,aAAKL,MAAL,CAAYoG,UAAZ,CAAuB/D,CAAC,CAAC0E,QAAF,EAAvB,EAAqC,KAAK1G,MAAL,GAAc,CAAnD;AACA,aAAKL,MAAL,CAAYoG,UAAZ,CAAuB/D,CAAC,CAAC2E,UAAF,EAAvB,EAAuC,KAAK3G,MAAL,GAAc,CAArD;AACA,aAAKL,MAAL,CAAYoG,UAAZ,CAAuB/D,CAAC,CAAC4E,UAAF,EAAvB,EAAuC,KAAK5G,MAAL,GAAc,CAArD;AACA,aAAKL,MAAL,CAAYgG,aAAZ,CAA0B3D,CAAC,CAAC6E,eAAF,KAAsB,IAAhD,EAAsD,KAAK7G,MAAL,GAAc,CAApE;AACD,OARD,MAQO;AACL,YAAI6B,QAAQ,KAAK,GAAjB,EAAsB;AACpB,cAAM7B,MAAM,GACV,CAAC6B,QAAQ,CAAC,CAAD,CAAR,KAAgB,GAAhB,GAAsB,CAAC,CAAvB,GAA2B,CAA5B,KACC0B,QAAQ,CAAC1B,QAAQ,CAACc,SAAT,CAAmB,CAAnB,EAAsB,CAAtB,CAAD,EAA2B,EAA3B,CAAR,GAAyC,EAAzC,GACCY,QAAQ,CAAC1B,QAAQ,CAACc,SAAT,CAAmB,CAAnB,CAAD,EAAwB,EAAxB,CAFV,CADF;;AAIA,cAAI3C,MAAM,KAAK,CAAf,EAAkB;AAChBgC,YAAAA,CAAC,GAAG,IAAIvD,IAAJ,CAASuD,CAAC,CAAC8E,OAAF,KAAc,QAAQ9G,MAA/B,CAAJ;AACD;AACF;;AACD,aAAKL,MAAL,CAAYmG,aAAZ,CAA0B9D,CAAC,CAAC+E,cAAF,EAA1B,EAA8C,KAAK/G,MAAL,GAAc,CAA5D;AACA,aAAKL,MAAL,CAAYoG,UAAZ,CAAuB/D,CAAC,CAACgF,WAAF,KAAkB,CAAzC,EAA4C,KAAKhH,MAAL,GAAc,CAA1D;AACA,aAAKL,MAAL,CAAYoG,UAAZ,CAAuB/D,CAAC,CAACiF,UAAF,EAAvB,EAAuC,KAAKjH,MAAL,GAAc,CAArD;AACA,aAAKL,MAAL,CAAYoG,UAAZ,CAAuB/D,CAAC,CAACkF,WAAF,EAAvB,EAAwC,KAAKlH,MAAL,GAAc,CAAtD;AACA,aAAKL,MAAL,CAAYoG,UAAZ,CAAuB/D,CAAC,CAACmF,aAAF,EAAvB,EAA0C,KAAKnH,MAAL,GAAc,CAAxD;AACA,aAAKL,MAAL,CAAYoG,UAAZ,CAAuB/D,CAAC,CAACoF,aAAF,EAAvB,EAA0C,KAAKpH,MAAL,GAAc,CAAxD;AACA,aAAKL,MAAL,CAAYgG,aAAZ,CAA0B3D,CAAC,CAACqF,kBAAF,KAAyB,IAAnD,EAAyD,KAAKrH,MAAL,GAAc,CAAvE;AACD;;AACD,WAAKA,MAAL,IAAe,EAAf;AACD;;;WAED,qBAAYF,UAAZ,EAAwB;AACtB,UAAME,MAAM,GAAG,KAAKA,MAApB;AACA,WAAKA,MAAL,GAAc,CAAd;AACA,WAAKsG,UAAL,CAAgB,KAAK3G,MAAL,CAAYV,MAAZ,GAAqB,CAArC;AACA,WAAK2G,SAAL,CAAe9F,UAAf;AACA,WAAKE,MAAL,GAAcA,MAAd;AACD;;;WAED,iBAAQ;AACN,aAAO,IAAIP,MAAJ,CAAW,KAAKK,UAAhB,EAA4B,KAAKH,MAAjC,EAAyC,KAAKC,KAA9C,EAAqD,KAAKC,GAA1D,CAAP;AACD;;;WAED,gBAAO;AACL,UAAI,KAAKyH,KAAL,EAAJ,EAAkB;AAChB,eAAO,KAAP;AACD;;AACD,UAAI,KAAKC,OAAL,EAAJ,EAAoB;AAClB,eAAO,OAAP;AACD;;AACD,UAAI,KAAK5H,MAAL,CAAY,KAAKK,MAAjB,MAA6B,CAAjC,EAAoC;AAClC,eAAO,SAAP,CADkC,CAChB;AACnB;;AACD,aAAO,EAAP;AACD;;;WAED,iCAA+B0F,CAA/B,EAAkC;AAChC,UAAIA,CAAC,GAAG,IAAR,EAAc;AACZ,eAAO,CAAP;AACD;;AACD,UAAIA,CAAC,GAAG,MAAR,EAAgB;AACd,eAAO,CAAP;AACD;;AACD,UAAIA,CAAC,GAAG,QAAR,EAAkB;AAChB,eAAO,CAAP;AACD;;AACD,aAAO,CAAP;AACD;;;WAED,iCAA+BpD,GAA/B,EAAoCQ,QAApC,EAA8C;AAC5C,UAAMqD,GAAG,GAAG5H,YAAY,CAAC6H,MAAb,CAAoB9D,GAApB,EAAyBQ,QAAzB,CAAZ;AACA,UAAM0E,IAAI,GAAGrB,GAAG,CAAClH,MAAjB;AACA,aAAOQ,MAAM,CAACgI,uBAAP,CAA+BD,IAA/B,IAAuCA,IAA9C;AACD;;;WAED,sBAAoB;AAClB,UAAME,IAAI,GAAG,SAAPA,IAAO,GAAW,CAAE,CAA1B;;AACA,UAAM3G,GAAG,GAAG1C,MAAM,CAACsJ,KAAP,CAAa,CAAb,CAAZ;;AACA,WAAK,IAAMC,EAAX,IAAiBxJ,YAAY,CAACyJ,SAA9B,EAAyC;AACvC,YAAI,OAAO9G,GAAG,CAAC6G,EAAD,CAAV,KAAmB,UAAvB,EAAmC;AACjC7G,UAAAA,GAAG,CAAC6G,EAAD,CAAH,GAAUF,IAAV;AACD;AACF;;AACD,aAAO3G,GAAP;AACD;;;;;;AAGH+G,MAAM,CAACC,OAAP,GAAiBtI,MAAjB","sourcesContent":["// This file was modified by Oracle on June 1, 2021.\n// A comment describing some changes in the strict default SQL mode regarding\n// non-standard dates was introduced.\n// Modifications copyright (c) 2021, Oracle and/or its affiliates.\n\n'use strict';\n\nconst ErrorCodeToName = require('../constants/errors.js');\nconst NativeBuffer = require('buffer').Buffer;\nconst Long = require('long');\nconst StringParser = require('../parsers/string.js');\n\nconst INVALID_DATE = new Date(NaN);\n\n// this is nearly duplicate of previous function so generated code is not slower\n// due to \"if (dateStrings)\" branching\nconst pad = '000000000000';\nfunction leftPad(num, value) {\n  const s = value.toString();\n  // if we don't need to pad\n  if (s.length >= num) {\n    return s;\n  }\n  return (pad + s).slice(-num);\n}\n\n// The whole reason parse* function below exist\n// is because String creation is relatively expensive (at least with V8), and if we have\n// a buffer with \"12345\" content ideally we would like to bypass intermediate\n// \"12345\" string creation and directly build 12345 number out of\n// <Buffer 31 32 33 34 35> data.\n// In my benchmarks the difference is ~25M 8-digit numbers per second vs\n// 4.5 M using Number(packet.readLengthCodedString())\n// not used when size is close to max precision as series of *10 accumulate error\n// and approximate result mihgt be diffreent from (approximate as well) Number(bigNumStringValue))\n// In the futire node version if speed difference is smaller parse* functions might be removed\n// don't consider them as Packet public API\n\nconst minus = '-'.charCodeAt(0);\nconst plus = '+'.charCodeAt(0);\n\n// TODO: handle E notation\nconst dot = '.'.charCodeAt(0);\nconst exponent = 'e'.charCodeAt(0);\nconst exponentCapital = 'E'.charCodeAt(0);\n\nclass Packet {\n  constructor(id, buffer, start, end) {\n    // hot path, enable checks when testing only\n    // if (!Buffer.isBuffer(buffer) || typeof start == 'undefined' || typeof end == 'undefined')\n    //  throw new Error('invalid packet');\n    this.sequenceId = id;\n    this.numPackets = 1;\n    this.buffer = buffer;\n    this.start = start;\n    this.offset = start + 4;\n    this.end = end;\n  }\n\n  // ==============================\n  // readers\n  // ==============================\n  reset() {\n    this.offset = this.start + 4;\n  }\n\n  length() {\n    return this.end - this.start;\n  }\n\n  slice() {\n    return this.buffer.slice(this.start, this.end);\n  }\n\n  dump() {\n    // eslint-disable-next-line no-console\n    console.log(\n      [this.buffer.asciiSlice(this.start, this.end)],\n      this.buffer.slice(this.start, this.end),\n      this.length(),\n      this.sequenceId\n    );\n  }\n\n  haveMoreData() {\n    return this.end > this.offset;\n  }\n\n  skip(num) {\n    this.offset += num;\n  }\n\n  readInt8() {\n    return this.buffer[this.offset++];\n  }\n\n  readInt16() {\n    this.offset += 2;\n    return this.buffer.readUInt16LE(this.offset - 2);\n  }\n\n  readInt24() {\n    return this.readInt16() + (this.readInt8() << 16);\n  }\n\n  readInt32() {\n    this.offset += 4;\n    return this.buffer.readUInt32LE(this.offset - 4);\n  }\n\n  readSInt8() {\n    return this.buffer.readInt8(this.offset++);\n  }\n\n  readSInt16() {\n    this.offset += 2;\n    return this.buffer.readInt16LE(this.offset - 2);\n  }\n\n  readSInt32() {\n    this.offset += 4;\n    return this.buffer.readInt32LE(this.offset - 4);\n  }\n\n  readInt64JSNumber() {\n    const word0 = this.readInt32();\n    const word1 = this.readInt32();\n    const l = new Long(word0, word1, true);\n    return l.toNumber();\n  }\n\n  readSInt64JSNumber() {\n    const word0 = this.readInt32();\n    const word1 = this.readInt32();\n    if (!(word1 & 0x80000000)) {\n      return word0 + 0x100000000 * word1;\n    }\n    const l = new Long(word0, word1, false);\n    return l.toNumber();\n  }\n\n  readInt64String() {\n    const word0 = this.readInt32();\n    const word1 = this.readInt32();\n    const res = new Long(word0, word1, true);\n    return res.toString();\n  }\n\n  readSInt64String() {\n    const word0 = this.readInt32();\n    const word1 = this.readInt32();\n    const res = new Long(word0, word1, false);\n    return res.toString();\n  }\n\n  readInt64() {\n    const word0 = this.readInt32();\n    const word1 = this.readInt32();\n    let res = new Long(word0, word1, true);\n    const resNumber = res.toNumber();\n    const resString = res.toString();\n    res = resNumber.toString() === resString ? resNumber : resString;\n    return res;\n  }\n\n  readSInt64() {\n    const word0 = this.readInt32();\n    const word1 = this.readInt32();\n    let res = new Long(word0, word1, false);\n    const resNumber = res.toNumber();\n    const resString = res.toString();\n    res = resNumber.toString() === resString ? resNumber : resString;\n    return res;\n  }\n\n  isEOF() {\n    return this.buffer[this.offset] === 0xfe && this.length() < 13;\n  }\n\n  eofStatusFlags() {\n    return this.buffer.readInt16LE(this.offset + 3);\n  }\n\n  eofWarningCount() {\n    return this.buffer.readInt16LE(this.offset + 1);\n  }\n\n  readLengthCodedNumber(bigNumberStrings, signed) {\n    const byte1 = this.buffer[this.offset++];\n    if (byte1 < 251) {\n      return byte1;\n    }\n    return this.readLengthCodedNumberExt(byte1, bigNumberStrings, signed);\n  }\n\n  readLengthCodedNumberSigned(bigNumberStrings) {\n    return this.readLengthCodedNumber(bigNumberStrings, true);\n  }\n\n  readLengthCodedNumberExt(tag, bigNumberStrings, signed) {\n    let word0, word1;\n    let res;\n    if (tag === 0xfb) {\n      return null;\n    }\n    if (tag === 0xfc) {\n      return this.readInt8() + (this.readInt8() << 8);\n    }\n    if (tag === 0xfd) {\n      return this.readInt8() + (this.readInt8() << 8) + (this.readInt8() << 16);\n    }\n    if (tag === 0xfe) {\n      // TODO: check version\n      // Up to MySQL 3.22, 0xfe was followed by a 4-byte integer.\n      word0 = this.readInt32();\n      word1 = this.readInt32();\n      if (word1 === 0) {\n        return word0; // don't convert to float if possible\n      }\n      if (word1 < 2097152) {\n        // max exact float point int, 2^52 / 2^32\n        return word1 * 0x100000000 + word0;\n      }\n      res = new Long(word0, word1, !signed); // Long need unsigned\n      const resNumber = res.toNumber();\n      const resString = res.toString();\n      res = resNumber.toString() === resString ? resNumber : resString;\n      return bigNumberStrings ? resString : res;\n    }\n    // eslint-disable-next-line no-console\n    console.trace();\n    throw new Error(`Should not reach here: ${tag}`);\n  }\n\n  readFloat() {\n    const res = this.buffer.readFloatLE(this.offset);\n    this.offset += 4;\n    return res;\n  }\n\n  readDouble() {\n    const res = this.buffer.readDoubleLE(this.offset);\n    this.offset += 8;\n    return res;\n  }\n\n  readBuffer(len) {\n    if (typeof len === 'undefined') {\n      len = this.end - this.offset;\n    }\n    this.offset += len;\n    return this.buffer.slice(this.offset - len, this.offset);\n  }\n\n  // DATE, DATETIME and TIMESTAMP\n  readDateTime(timezone) {\n    if (!timezone || timezone === 'Z' || timezone === 'local') {\n      const length = this.readInt8();\n      if (length === 0xfb) {\n        return null;\n      }\n      let y = 0;\n      let m = 0;\n      let d = 0;\n      let H = 0;\n      let M = 0;\n      let S = 0;\n      let ms = 0;\n      if (length > 3) {\n        y = this.readInt16();\n        m = this.readInt8();\n        d = this.readInt8();\n      }\n      if (length > 6) {\n        H = this.readInt8();\n        M = this.readInt8();\n        S = this.readInt8();\n      }\n      if (length > 10) {\n        ms = this.readInt32() / 1000;\n      }\n      // NO_ZERO_DATE mode and NO_ZERO_IN_DATE mode are part of the strict\n      // default SQL mode used by MySQL 8.0. This means that non-standard\n      // dates like '0000-00-00' become NULL. For older versions and other\n      // possible MySQL flavours we still need to account for the\n      // non-standard behaviour.\n      if (y + m + d + H + M + S + ms === 0) {\n        return INVALID_DATE;\n      }\n      if (timezone === 'Z') {\n        return new Date(Date.UTC(y, m - 1, d, H, M, S, ms));\n      }\n      return new Date(y, m - 1, d, H, M, S, ms);\n    }\n    let str = this.readDateTimeString(6, 'T');\n    if (str.length === 10) {\n      str += 'T00:00:00';\n    }\n    return new Date(str + timezone);\n  }\n\n  readDateTimeString(decimals, timeSep) {\n    const length = this.readInt8();\n    let y = 0;\n    let m = 0;\n    let d = 0;\n    let H = 0;\n    let M = 0;\n    let S = 0;\n    let ms = 0;\n    let str;\n    if (length > 3) {\n      y = this.readInt16();\n      m = this.readInt8();\n      d = this.readInt8();\n      str = [leftPad(4, y), leftPad(2, m), leftPad(2, d)].join('-');\n    }\n    if (length > 6) {\n      H = this.readInt8();\n      M = this.readInt8();\n      S = this.readInt8();\n      str += `${timeSep || ' '}${[\n        leftPad(2, H),\n        leftPad(2, M),\n        leftPad(2, S)\n      ].join(':')}`;\n    }\n    if (length > 10) {\n      ms = this.readInt32();\n      str += '.';\n      if (decimals) {\n        ms = leftPad(6, ms);\n        if (ms.length > decimals) {\n          ms = ms.substring(0, decimals); // rounding is done at the MySQL side, only 0 are here\n        }\n      }\n      str += ms;\n    }\n    return str;\n  }\n\n  // TIME - value as a string, Can be negative\n  readTimeString(convertTtoMs) {\n    const length = this.readInt8();\n    if (length === 0) {\n      return '00:00:00';\n    }\n    const sign = this.readInt8() ? -1 : 1; // 'isNegative' flag byte\n    let d = 0;\n    let H = 0;\n    let M = 0;\n    let S = 0;\n    let ms = 0;\n    if (length > 6) {\n      d = this.readInt32();\n      H = this.readInt8();\n      M = this.readInt8();\n      S = this.readInt8();\n    }\n    if (length > 10) {\n      ms = this.readInt32();\n    }\n    if (convertTtoMs) {\n      H += d * 24;\n      M += H * 60;\n      S += M * 60;\n      ms += S * 1000;\n      ms *= sign;\n      return ms;\n    }\n    return (\n      (sign === -1 ? '-' : '') +\n      [d ? d * 24 + H : H, leftPad(2, M), leftPad(2, S)].join(':') +\n      (ms ? `.${ms}` : '')\n    );\n  }\n\n  readLengthCodedString(encoding) {\n    const len = this.readLengthCodedNumber();\n    // TODO: check manually first byte here to avoid polymorphic return type?\n    if (len === null) {\n      return null;\n    }\n    this.offset += len;\n    // TODO: Use characterSetCode to get proper encoding\n    // https://github.com/sidorares/node-mysql2/pull/374\n    return StringParser.decode(\n      this.buffer.slice(this.offset - len, this.offset),\n      encoding\n    );\n  }\n\n  readLengthCodedBuffer() {\n    const len = this.readLengthCodedNumber();\n    if (len === null) {\n      return null;\n    }\n    return this.readBuffer(len);\n  }\n\n  readNullTerminatedString(encoding) {\n    const start = this.offset;\n    let end = this.offset;\n    while (this.buffer[end]) {\n      end = end + 1; // TODO: handle OOB check\n    }\n    this.offset = end + 1;\n    return StringParser.decode(this.buffer.slice(start, end), encoding);\n  }\n\n  // TODO reuse?\n  readString(len, encoding) {\n    if ((typeof len === 'string') && (typeof encoding === 'undefined')) {\n      encoding = len\n      len = undefined\n    }\n    if (typeof len === 'undefined') {\n      len = this.end - this.offset;\n    }\n    this.offset += len;\n    return StringParser.decode(\n      this.buffer.slice(this.offset - len, this.offset),\n      encoding\n    );\n  }\n\n  parseInt(len, supportBigNumbers) {\n    if (len === null) {\n      return null;\n    }\n    if (len >= 14 && !supportBigNumbers) {\n      const s = this.buffer.toString('ascii', this.offset, this.offset + len);\n      this.offset += len;\n      return Number(s);\n    }\n    let result = 0;\n    const start = this.offset;\n    const end = this.offset + len;\n    let sign = 1;\n    if (len === 0) {\n      return 0; // TODO: assert? exception?\n    }\n    if (this.buffer[this.offset] === minus) {\n      this.offset++;\n      sign = -1;\n    }\n    // max precise int is 9007199254740992\n    let str;\n    const numDigits = end - this.offset;\n    if (supportBigNumbers) {\n      if (numDigits >= 15) {\n        str = this.readString(end - this.offset, 'binary');\n        result = parseInt(str, 10);\n        if (result.toString() === str) {\n          return sign * result;\n        }\n        return sign === -1 ? `-${str}` : str;\n      }\n      if (numDigits > 16) {\n        str = this.readString(end - this.offset);\n        return sign === -1 ? `-${str}` : str;\n      }\n    }\n    if (this.buffer[this.offset] === plus) {\n      this.offset++; // just ignore\n    }\n    while (this.offset < end) {\n      result *= 10;\n      result += this.buffer[this.offset] - 48;\n      this.offset++;\n    }\n    const num = result * sign;\n    if (!supportBigNumbers) {\n      return num;\n    }\n    str = this.buffer.toString('ascii', start, end);\n    if (num.toString() === str) {\n      return num;\n    }\n    return str;\n  }\n\n  // note that if value of inputNumberAsString is bigger than MAX_SAFE_INTEGER\n  // ( or smaller than MIN_SAFE_INTEGER ) the parseIntNoBigCheck result might be\n  // different from what you would get from Number(inputNumberAsString)\n  // String(parseIntNoBigCheck) <> String(Number(inputNumberAsString)) <> inputNumberAsString\n  parseIntNoBigCheck(len) {\n    if (len === null) {\n      return null;\n    }\n    let result = 0;\n    const end = this.offset + len;\n    let sign = 1;\n    if (len === 0) {\n      return 0; // TODO: assert? exception?\n    }\n    if (this.buffer[this.offset] === minus) {\n      this.offset++;\n      sign = -1;\n    }\n    if (this.buffer[this.offset] === plus) {\n      this.offset++; // just ignore\n    }\n    while (this.offset < end) {\n      result *= 10;\n      result += this.buffer[this.offset] - 48;\n      this.offset++;\n    }\n    return result * sign;\n  }\n\n  // copy-paste from https://github.com/mysqljs/mysql/blob/master/lib/protocol/Parser.js\n  parseGeometryValue() {\n    const buffer = this.readLengthCodedBuffer();\n    let offset = 4;\n    if (buffer === null || !buffer.length) {\n      return null;\n    }\n    function parseGeometry() {\n      let x, y, i, j, numPoints, line;\n      let result = null;\n      const byteOrder = buffer.readUInt8(offset);\n      offset += 1;\n      const wkbType = byteOrder\n        ? buffer.readUInt32LE(offset)\n        : buffer.readUInt32BE(offset);\n      offset += 4;\n      switch (wkbType) {\n        case 1: // WKBPoint\n          x = byteOrder\n            ? buffer.readDoubleLE(offset)\n            : buffer.readDoubleBE(offset);\n          offset += 8;\n          y = byteOrder\n            ? buffer.readDoubleLE(offset)\n            : buffer.readDoubleBE(offset);\n          offset += 8;\n          result = { x: x, y: y };\n          break;\n        case 2: // WKBLineString\n          numPoints = byteOrder\n            ? buffer.readUInt32LE(offset)\n            : buffer.readUInt32BE(offset);\n          offset += 4;\n          result = [];\n          for (i = numPoints; i > 0; i--) {\n            x = byteOrder\n              ? buffer.readDoubleLE(offset)\n              : buffer.readDoubleBE(offset);\n            offset += 8;\n            y = byteOrder\n              ? buffer.readDoubleLE(offset)\n              : buffer.readDoubleBE(offset);\n            offset += 8;\n            result.push({ x: x, y: y });\n          }\n          break;\n        case 3: // WKBPolygon\n          // eslint-disable-next-line no-case-declarations\n          const numRings = byteOrder\n            ? buffer.readUInt32LE(offset)\n            : buffer.readUInt32BE(offset);\n          offset += 4;\n          result = [];\n          for (i = numRings; i > 0; i--) {\n            numPoints = byteOrder\n              ? buffer.readUInt32LE(offset)\n              : buffer.readUInt32BE(offset);\n            offset += 4;\n            line = [];\n            for (j = numPoints; j > 0; j--) {\n              x = byteOrder\n                ? buffer.readDoubleLE(offset)\n                : buffer.readDoubleBE(offset);\n              offset += 8;\n              y = byteOrder\n                ? buffer.readDoubleLE(offset)\n                : buffer.readDoubleBE(offset);\n              offset += 8;\n              line.push({ x: x, y: y });\n            }\n            result.push(line);\n          }\n          break;\n        case 4: // WKBMultiPoint\n        case 5: // WKBMultiLineString\n        case 6: // WKBMultiPolygon\n        case 7: // WKBGeometryCollection\n          // eslint-disable-next-line no-case-declarations\n          const num = byteOrder\n            ? buffer.readUInt32LE(offset)\n            : buffer.readUInt32BE(offset);\n          offset += 4;\n          result = [];\n          for (i = num; i > 0; i--) {\n            result.push(parseGeometry());\n          }\n          break;\n      }\n      return result;\n    }\n    return parseGeometry();\n  }\n\n  parseDate(timezone) {\n    const strLen = this.readLengthCodedNumber();\n    if (strLen === null) {\n      return null;\n    }\n    if (strLen !== 10) {\n      // we expect only YYYY-MM-DD here.\n      // if for some reason it's not the case return invalid date\n      return new Date(NaN);\n    }\n    const y = this.parseInt(4);\n    this.offset++; // -\n    const m = this.parseInt(2);\n    this.offset++; // -\n    const d = this.parseInt(2);\n    if (!timezone || timezone === 'local') {\n      return new Date(y, m - 1, d);\n    }\n    if (timezone === 'Z') {\n      return new Date(Date.UTC(y, m - 1, d));\n    }\n    return new Date(\n      `${leftPad(4, y)}-${leftPad(2, m)}-${leftPad(2, d)}T00:00:00${timezone}`\n    );\n  }\n\n  parseDateTime(timezone) {\n    const str = this.readLengthCodedString('binary');\n    if (str === null) {\n      return null;\n    }\n    if (!timezone || timezone === 'local') {\n      return new Date(str);\n    }\n    return new Date(`${str}${timezone}`);\n  }\n\n  parseFloat(len) {\n    if (len === null) {\n      return null;\n    }\n    let result = 0;\n    const end = this.offset + len;\n    let factor = 1;\n    let pastDot = false;\n    let charCode = 0;\n    if (len === 0) {\n      return 0; // TODO: assert? exception?\n    }\n    if (this.buffer[this.offset] === minus) {\n      this.offset++;\n      factor = -1;\n    }\n    if (this.buffer[this.offset] === plus) {\n      this.offset++; // just ignore\n    }\n    while (this.offset < end) {\n      charCode = this.buffer[this.offset];\n      if (charCode === dot) {\n        pastDot = true;\n        this.offset++;\n      } else if (charCode === exponent || charCode === exponentCapital) {\n        this.offset++;\n        const exponentValue = this.parseInt(end - this.offset);\n        return (result / factor) * Math.pow(10, exponentValue);\n      } else {\n        result *= 10;\n        result += this.buffer[this.offset] - 48;\n        this.offset++;\n        if (pastDot) {\n          factor = factor * 10;\n        }\n      }\n    }\n    return result / factor;\n  }\n\n  parseLengthCodedIntNoBigCheck() {\n    return this.parseIntNoBigCheck(this.readLengthCodedNumber());\n  }\n\n  parseLengthCodedInt(supportBigNumbers) {\n    return this.parseInt(this.readLengthCodedNumber(), supportBigNumbers);\n  }\n\n  parseLengthCodedIntString() {\n    return this.readLengthCodedString('binary');\n  }\n\n  parseLengthCodedFloat() {\n    return this.parseFloat(this.readLengthCodedNumber());\n  }\n\n  peekByte() {\n    return this.buffer[this.offset];\n  }\n\n  // OxFE is often used as \"Alt\" flag - not ok, not error.\n  // For example, it's first byte of AuthSwitchRequest\n  isAlt() {\n    return this.peekByte() === 0xfe;\n  }\n\n  isError() {\n    return this.peekByte() === 0xff;\n  }\n\n  asError(encoding) {\n    this.reset();\n    this.readInt8(); // fieldCount\n    const errorCode = this.readInt16();\n    let sqlState = '';\n    if (this.buffer[this.offset] === 0x23) {\n      this.skip(1);\n      sqlState = this.readBuffer(5).toString();\n    }\n    const message = this.readString(undefined, encoding);\n    const err = new Error(message);\n    err.code = ErrorCodeToName[errorCode];\n    err.errno = errorCode;\n    err.sqlState = sqlState;\n    err.sqlMessage = message;\n    return err;\n  }\n\n  writeInt32(n) {\n    this.buffer.writeUInt32LE(n, this.offset);\n    this.offset += 4;\n  }\n\n  writeInt24(n) {\n    this.writeInt8(n & 0xff);\n    this.writeInt16(n >> 8);\n  }\n\n  writeInt16(n) {\n    this.buffer.writeUInt16LE(n, this.offset);\n    this.offset += 2;\n  }\n\n  writeInt8(n) {\n    this.buffer.writeUInt8(n, this.offset);\n    this.offset++;\n  }\n\n  writeDouble(n) {\n    this.buffer.writeDoubleLE(n, this.offset);\n    this.offset += 8;\n  }\n\n  writeBuffer(b) {\n    b.copy(this.buffer, this.offset);\n    this.offset += b.length;\n  }\n\n  writeNull() {\n    this.buffer[this.offset] = 0xfb;\n    this.offset++;\n  }\n\n  // TODO: refactor following three?\n  writeNullTerminatedString(s, encoding) {\n    const buf = StringParser.encode(s, encoding);\n    this.buffer.length && buf.copy(this.buffer, this.offset);\n    this.offset += buf.length;\n    this.writeInt8(0);\n  }\n\n  writeString(s, encoding) {\n    if (s === null) {\n      this.writeInt8(0xfb);\n      return;\n    }\n    if (s.length === 0) {\n      return;\n    }\n    // const bytes = Buffer.byteLength(s, 'utf8');\n    // this.buffer.write(s, this.offset, bytes, 'utf8');\n    // this.offset += bytes;\n    const buf = StringParser.encode(s, encoding);\n    this.buffer.length && buf.copy(this.buffer, this.offset);\n    this.offset += buf.length;\n  }\n\n  writeLengthCodedString(s, encoding) {\n    const buf = StringParser.encode(s, encoding);\n    this.writeLengthCodedNumber(buf.length);\n    this.buffer.length && buf.copy(this.buffer, this.offset);\n    this.offset += buf.length;\n  }\n\n  writeLengthCodedBuffer(b) {\n    this.writeLengthCodedNumber(b.length);\n    b.copy(this.buffer, this.offset);\n    this.offset += b.length;\n  }\n\n  writeLengthCodedNumber(n) {\n    if (n < 0xfb) {\n      return this.writeInt8(n);\n    }\n    if (n < 0xffff) {\n      this.writeInt8(0xfc);\n      return this.writeInt16(n);\n    }\n    if (n < 0xffffff) {\n      this.writeInt8(0xfd);\n      return this.writeInt24(n);\n    }\n    if (n === null) {\n      return this.writeInt8(0xfb);\n    }\n    // TODO: check that n is out of int precision\n    this.writeInt8(0xfe);\n    this.buffer.writeUInt32LE(n, this.offset);\n    this.offset += 4;\n    this.buffer.writeUInt32LE(n >> 32, this.offset);\n    this.offset += 4;\n    return this.offset;\n  }\n\n  writeDate(d, timezone) {\n    this.buffer.writeUInt8(11, this.offset);\n    if (!timezone || timezone === 'local') {\n      this.buffer.writeUInt16LE(d.getFullYear(), this.offset + 1);\n      this.buffer.writeUInt8(d.getMonth() + 1, this.offset + 3);\n      this.buffer.writeUInt8(d.getDate(), this.offset + 4);\n      this.buffer.writeUInt8(d.getHours(), this.offset + 5);\n      this.buffer.writeUInt8(d.getMinutes(), this.offset + 6);\n      this.buffer.writeUInt8(d.getSeconds(), this.offset + 7);\n      this.buffer.writeUInt32LE(d.getMilliseconds() * 1000, this.offset + 8);\n    } else {\n      if (timezone !== 'Z') {\n        const offset =\n          (timezone[0] === '-' ? -1 : 1) *\n          (parseInt(timezone.substring(1, 3), 10) * 60 +\n            parseInt(timezone.substring(4), 10));\n        if (offset !== 0) {\n          d = new Date(d.getTime() + 60000 * offset);\n        }\n      }\n      this.buffer.writeUInt16LE(d.getUTCFullYear(), this.offset + 1);\n      this.buffer.writeUInt8(d.getUTCMonth() + 1, this.offset + 3);\n      this.buffer.writeUInt8(d.getUTCDate(), this.offset + 4);\n      this.buffer.writeUInt8(d.getUTCHours(), this.offset + 5);\n      this.buffer.writeUInt8(d.getUTCMinutes(), this.offset + 6);\n      this.buffer.writeUInt8(d.getUTCSeconds(), this.offset + 7);\n      this.buffer.writeUInt32LE(d.getUTCMilliseconds() * 1000, this.offset + 8);\n    }\n    this.offset += 12;\n  }\n\n  writeHeader(sequenceId) {\n    const offset = this.offset;\n    this.offset = 0;\n    this.writeInt24(this.buffer.length - 4);\n    this.writeInt8(sequenceId);\n    this.offset = offset;\n  }\n\n  clone() {\n    return new Packet(this.sequenceId, this.buffer, this.start, this.end);\n  }\n\n  type() {\n    if (this.isEOF()) {\n      return 'EOF';\n    }\n    if (this.isError()) {\n      return 'Error';\n    }\n    if (this.buffer[this.offset] === 0) {\n      return 'maybeOK'; // could be other packet types as well\n    }\n    return '';\n  }\n\n  static lengthCodedNumberLength(n) {\n    if (n < 0xfb) {\n      return 1;\n    }\n    if (n < 0xffff) {\n      return 3;\n    }\n    if (n < 0xffffff) {\n      return 5;\n    }\n    return 9;\n  }\n\n  static lengthCodedStringLength(str, encoding) {\n    const buf = StringParser.encode(str, encoding);\n    const slen = buf.length;\n    return Packet.lengthCodedNumberLength(slen) + slen;\n  }\n\n  static MockBuffer() {\n    const noop = function() {};\n    const res = Buffer.alloc(0);\n    for (const op in NativeBuffer.prototype) {\n      if (typeof res[op] === 'function') {\n        res[op] = noop;\n      }\n    }\n    return res;\n  }\n}\n\nmodule.exports = Packet;\n"]},"metadata":{},"sourceType":"script"}